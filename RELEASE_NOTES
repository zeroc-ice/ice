======================================================================
Release notes for Ice 3.3.1
======================================================================

Introduction
------------

This document outlines changes and improvements in this release that
may affect the operation of your applications or have an impact on
your source code. Refer to the "Upgrading" sections for more
information about migrating to a new Ice release.

The main purpose of a patch release such as this one is to correct
defects while maintaining binary compatibility with the most recent
minor release (3.3). This patch release also introduces a few 
enhancements and new features while maintaining binary compatibility.

For a detailed list of the changes in this release, please refer to
the CHANGES file included in your Ice distribution.


Table of Contents
-----------------

  1. New Features
  2. Upgrading your application from Ice 3.3
     - Java language mapping changes
     - Changes to the Java API for Freeze maps
     - Freeze packaging
     - PHP changes
     - IceSSL changes
  3. Upgrading your application from Ice 3.2 or earlier releases
     - Compatibility
     - Migrating IceStorm databases
     - Migrating IceGrid databases
     - Migrating Freeze databases
     - Removed APIs
     - Deprecated APIs
  4. Platform-specific notes
     - Supported platforms
     - Java and IPv6
     - Mono
     - Red Hat Enterprise Linux 5.1
     - IBM JDK
  5. Known Problems
     - Slice-to-HTML
     - UNC Paths and Slice compilers
     - C++Builder 2009 Bugs


======================================================================
1. New Features
======================================================================

This section discusses the significant enhancements in Ice 3.4.

- ConnectionInfo/EndpointInfo

TBD


Features added with 3.3.1
=========================


Java and .NET serialization
---------------------------

This release adds support for Java and .NET serializable classes. You
can now enable the serialization, transmission, and deserialization
of Java and .NET classes with a simple metadata directive. As an
example, the Slice definition shown below specifies the name of a
serializable Java class:

// Slice
["java:serializable:Demo.MyGreeting"] sequence<byte> Greeting;

This definition allows you to transfer instances of Demo.MyGreeting as
a byte sequence while Ice handles the low-level serialization chores.

You can read more about this feature in the Ice manual. We have also
included a new sample program for each of the supported languages.


Background locator updates
--------------------------

For an indirect proxy, the Ice run time queries the locator and caches
the resulting endpoints. By default, Ice caches these endpoints
indefinitely unless the proxy is configured with a cache timeout, in
which case Ice must update the cached endpoints after the timeout
expires by issuing a new locator query. This update occurs upon the
next invocation on the proxy, and in previous releases the update
would delay the invocation until the new endpoints were obtained from
the locator.

This update can now be performed in the background by setting the new
property Ice.BackgroundLocatorCacheUpdates to 1. With this feature
enabled, Ice allows the invocation that triggered the update to use
the previously-cached endpoints while the locator query completes in
the background.


Glacier2 session destruction
----------------------------

Glacier2 now automatically destroys the client session if the
forwarding of a request from a back-end server to the client fails
with an unrecoverable error. This is particularly useful for clients
that receive requests from back-end servers on a regular basis and
disable the Glacier2 session timeout. If for some reason the client
becomes unreachable, Glacier2 will eventually destroy the client
session (assuming timeouts are properly configured on the Glacier2
client endpoints).


Java Applets
------------

It is now possible to use Ice for Java in an applet. Additionally,
IceSSL can now obtain keystores, truststores, and RNG seeds from class
path resources using configuration properties or programmatically
using input streams.


New sample programs
-------------------

This release adds the following sample programs:

  - serialize (.NET, Java)

    Shows how to transfer serializable classes with Ice.

  - nrvo (C++)

    Highlights the benefits of Named Return Value Optimization (NRVO).
    See the section titled "Upgrading your application from Ice 3.3.0"
    for more information on NRVO.

  - applet (Java)

    Shows how to use asynchronous invocations in an applet and how to
    configure IceSSL using class path resources.

  - Database (Java)

    A client/server application in which the server accesses MySQL via
    the JDBC API.


Features added with 3.3.0
=========================


AMI
---

AMI requests are now guaranteed non-blocking. New proxy methods,
ice_flushBatchRequests and ice_flushBatchRequests_async, allow
flushing of requests batched for a connection. The latter method
is guaranteed to not block. AMI requests can now be sent oneway.


Threads
-------

The Ice thread pool now supports serialization of requests received
over a connection.


Exceptions
----------

Exceptions thrown from collocation-optimized invocations are now fully
transparent, so a collocated invocation raises the same exception as a
remote invocation. (Previously, a collocated invocation raised the
original exception whereas the corresponding remote invocation raised
an unknown exception.)

Servant locators now can throw a user exception from the locate and
finished operations.


Transports
----------

The run time now tries to connect to multi-homed hosts on all IP
addresses returned by the DNS.

Ice.TCP.Backlog allows control of the incoming connection backlog.

Ice now supports IPv6.

Ice now supports UDP multicast.

A new adapter operation, refreshPublishedEndpoints, permits you to
update an adapter's published endpoints after a change to the
available network interfaces or an update to the PublishedEndpoints
property.

Ice now listens on INADDR_ANY for endpoints that do not specify a
host, instead of listening only on the interfaces that were present
when the adapter was created.


IceBox
------

IceBox can now recursively start and stop other IceBox services.

IceBox properties can now be defined on the command line.

Setting IceBox.ServiceManager.Endpoints is now optional.


IceStorm
--------

IceStorm now supports master/slave replication with automatic
failover.

IceStorm now has a transient mode that allows it to run without a
database.

IceStorm subscriptions are now persistent (except in transient mode).

A new QoS parameter, retryCount, allows you to control after how many
soft failures a subscription is removed.

A new replication2 demo illustrates how to manually configure
replication.

IceStorm now guarantees ordering by default even for oneway proxies.


Freeze
------

The existing evictor is now named BackgroundSaveEvictor. A new
evictor, TransactionalEvictor, makes updates in a transaction.


IceGrid
-------

A new secure demo illustrates how to secure an IceGrid deployment.


Miscellaneous features
----------------------

Ice for Java now supports the ICE_CONFIG environment variable.

Ice.Application now supports signal handling with Mono.

Improved marshaling performance with Ice for .NET.

Ice for .NET now supports C# 2.0 generics for sequences and
dictionaries.

Ice for Python now includes a converter demo that illustrates
how to use the C++ string converter plug-in.

Ice for Python now supports blobjects.


======================================================================
2. Upgrading your application from Ice 3.3
======================================================================


Java language mapping changes
=============================

The Java2 language mapping, which was deprecated in Ice 3.3, is no
longer supported. The Slice compiler and Ice API now use the Java5
language mapping exclusively, therefore upgrading to Ice 3.4 may
require modifications to your application's source code. The
subsections below discuss the language mapping features that are
affected by this change and describe how to modify your application
accordingly.


Metadata
--------

The global metadata directives "java:java2" and "java:java5" are no
longer supported and should be removed from your Slice files. The
Slice compiler now emits a warning about these directives.

Support for the portable metadata syntax has also been removed. This
syntax allowed Slice definitions to define custom type metadata that
the Slice compiler would translate to match the desired target
mapping. For example:

  // Slice
  ["java:type:{java.util.ArrayList}"] sequence<String> StringList;

The braces surrounding the custom type "java.util.ArrayList" directed
the Slice compiler to use "java.util.ArrayList<String>" in the Java5
mapping and "java.util.ArrayList" in the Java2 mapping.

All uses of the portable metadata syntax must be changed to use the
corresponding Java5 equivalent.


Dictionaries
------------

Since Slice dictionary types now use the Java5 mapping, recompiling
your Slice files and your application may cause the Java compiler to
emit "unchecked" warnings. This occurs when your code attempts to
assign an untyped collection class such as "java.util.Map" to a
generic type such as "java.util.Map<String, String>". Consider the
following example:

  // Slice
  dictionary<string, int> ValueMap;

  interface Table {
      void setValues(ValueMap m);
  };

A Java2 application might have used these Slice definitions as shown
below:

  // Java
  java.util.Map values = new java.util.HashMap();
  values.put(...);

  TablePrx proxy = ...;
  proxy.setValues(values); // Warning

The call to setValues() is an example of an unchecked conversion. We
recommend that you compile your application using the compiler option
shown below:

  javac -Xlint:unchecked ...

This option causes the compiler to generate descriptive warnings about
occurrences of unchecked conversions to help you find and correct the
offending code.


Contexts
--------

The Slice type Ice::Context is defined as follows:

  // Slice
  module Ice {
      dictionary<string, string> Context;
  };

As a dictionary, the Context type is subject to the same issues
regarding unchecked conversions described in the "Dictionaries"
section above. For example, each proxy operation maps to two
overloaded methods, one that omits the trailing Context parameter and
one that includes it:

  // Java
  interface TablePrx {
      void setValues(java.util.Map<String, Integer> m);  // No context

      void setValues(java.util.Map<String, Integer> m,
                     java.util.Map<String, String> ctx);
  }

If your proxy invocations make use of this parameter, you will need to
change your code to use the generic type shown above in order to
eliminate unchecked conversion warnings.


Enumerations
------------

The Java2 language mapping for a Slice enumeration generated a class
whose API differed in several ways from the standard Java5 enum type.
Consider the following enumeration:

  // Slice
  enum Color { red, green, blue };

The Java2 language mapping for Color is shown below:

  // Java
  public final class Color
  {
      // Integer constants
      public static final int _red = 0;
      public static final int _green = 1;
      public static final int _blue = 2;

      // Enumerators
      public static final Color red = ...;
      public static final Color green = ...;
      public static final Color blue = ...;

      // Helpers
      public static Color convert(int val);
      public static Color convert(String val);
      public int value();

      ...
  }

The first step in migrating to the Java5 mapping for enumerations is
to modify all switch statements that use an enumerator. Before Java
added native support for enumerations, the switch statement could only
use the integer value of the enumerator and therefore the Java2
mapping supplied integer constants for use in case statements. For
example, here is a switch statement that uses the Java2 mapping:

  // Java
  Color col = ...;
  switch(col.value())
  {
  case Color._red:
      ...
      break;
  case Color._green:
      ...
      break;
  case Color._blue:
      ...
      break;
  }

The Java5 mapping eliminates the integer constants because Java5
allows enumerators to be used in case statements. The resulting code
becomes much easier to read and write:

  // Java
  Color col = ...;
  switch(col)
  {
  case red:
      ...
      break;
  case green:
      ...
      break;
  case blue:
      ...
      break;
  }

The next step is to replace any uses of the value() or convert()
methods with their Java5 equivalents. The base class for all Java5
enumerations (java.lang.Enum) supplies methods with similar
functionality:

  static Color[] values()          // replaces convert(int)
  static Color valueOf(String val) // replaces convert(String)
  int ordinal()                    // replaces value()

For example, here is the Java5 code to convert an integer into its
equivalent enumerator:

  Color r = Color.values()[0]; // red

Note however that the convert(String) method in the Java2 mapping
returned null for an invalid argument, whereas the Java5 enum method
valueOf raises IllegalArgumentException instead.


Changes to the Java API for Freeze maps
=======================================

The Java API for Freeze maps has been revised to used Java5 generic
types and enhanced to provide additional functionality. This section
describes these changes in detail and explains how to migrate your
Freeze application to the API in Ice 3.4.


General changes
---------------

The Freeze API is now entirely type-safe, which means compiling your
application against Ice 3.4 is likely to generate unchecked conversion
warnings. The generated class for a Freeze map now implements the
java.util.SortedMap<K, V> interface, where K is the key type and V is
the value type. As a result, applications that relied on the untyped
SortedMap API (where all keys and values were treated as instances of
java.lang.Object) will encounter compiler warnings in Ice 3.4.

For example, an application might have iterated over the entries in a
map as follows:

// Old API
Object key = new Integer(5);
Object value = new Address(...);
myMap.put(key, value);
java.util.Iterator i = myMap.entrySet().iterator();
while (i.hasNext()) {
    java.util.Map.Entry e = (java.util.Map.Entry)i.next();
    Integer myKey = (Integer)e.getKey();
    Address myValue = (Address)e.getValue();
    ...
}

This code will continue to work, but the new API is both type-safe
and self-documenting:

// New API
int key = 5;
Address value = new Address(...);
myMap.put(key, value); // The key is autoboxed to Integer.
for (java.util.Map.Entry<Integer, Address> e : myMap.entrySet()) {
    Integer myKey = e.getKey();
    Address myValue = e.getValue();
    ...
}

Although migrating to the new API may require some effort, the
benefits are worthwhile because your code will be easier to read and
less prone to defects. You can also take advantage of the "autoboxing"
features in Java5 that automatically convert values of primitive types
(such as int) into their object equivalents (such as Integer).

Please refer to the Ice manual for complete details on the new API.


Enhancements
------------

Java6 introduced the java.util.NavigableMap interface, which extends
java.util.SortedMap to add some useful new methods. Although the
Freeze map API cannot implement java.util.NavigableMap directly
because Freeze must remain compatible with Java5, we have added the
Freeze.NavigableMap interface to provide much of the same
functionality. A generated Freeze map class implements NavigableMap,
as do the sub map views returned by map methods such as headMap.
The NavigableMap interface is described in the Ice manual, and you can
also refer to the Java6 API documentation.


Backward compatibility
----------------------

The Freeze Map API related to indices underwent some significant
changes in order to improve type safety and avoid unchecked
conversion warnings. These changes may cause compilation failures in a
Freeze application.

In the previous API, index comparator objects were supplied to the
Freeze map constructor in a map (in Java5 syntax, this comparators map
would have the type java.util.Map<String, java.util.Comparator>) in
which the index name was the key. As part of our efforts to improve
type safety, we also wanted to use the fully-specified type for each
index comparator (such as java.util.Comparator<Integer>). However,
given that each index could potentially use a different key type, it
is not possible to retain the previous API while remaining type-safe.

Consequently, the index comparators are now supplied as data members
of a static nested class of the Freeze map named IndexComparators. If
your application supplied custom comparators for indices, you will
need to revise your code to use IndexComparators instead. For example:

// Old API
java.util.Map indexComparators = new java.util.HashMap();
indexComparators.put("index", new MyComparator());
MyMap map = new MyMap(..., indexComparators);

// New API
MyMap.IndexComparators indexComparators =
    new MyMap.IndexComparators();
indexComparators.valueComparator = new MyComparator();
MyMap map = new MyMap(..., indexComparators);

We also encourage you to modify the definition of your comparator
classes to use the Java5 syntax, as shown in the example below:

// Old comparator
class IntComparator implements java.util.Comparator
{
    public int compare(Object o1, Object o2)
    {
        return ((Integer)o1).compareTo(o2);
    }
}

// New comparator
class IntComparator implements java.util.Comparator<Integer>
{
    public int compare(Integer i1, Integer i2)
    {
        return i1.compareTo(i2);
    }
}

The second API change that might cause compilation failures is the
removal of the following methods:

    java.util.SortedMap headMapForIndex(String name, Object key);
    java.util.SortedMap tailMapForIndex(String name, Object key);
    java.util.SortedMap subMapForIndex(String name, Object from,
                                       Object to);
    java.util.SortedMap mapForIndex(String name);

Again, this API cannot be retained in a type-safe fashion, therefore
slice2freezej now generates equivalent (and type-safe) methods for
each index in the Freeze map class.

Please refer to the Ice manual for complete details on the new API.


Finalizers
----------

In previous releases, Freeze for Java used finalizers to close objects
such as maps and connections that the application neglected to close.
Most of these finalizers have been removed in Ice 3.4, and the only
remaining finalizers simply log warning messages to alert you to the
fact that connections and iterators are not being closed explicitly.
Note that, given the uncertain nature of Java finalizers, it is quite
likely that the remaining finalizers will not be executed.


Freeze packaging
================

All Freeze-related classes are now stored in a separate JAR file named
Freeze.jar. As a result, you may need to update your build scripts,
deployment configuration, and run-time environment to include this
additional JAR file.


PHP changes
===========

The Ice extension for PHP has undergone many changes in this release.
The subsections below describe these changes in detail.


Static translation
------------------

In prior releases, Slice files were deployed with the application and
loaded at Web server startup by the Ice extension. Before each page
request, the extension directed the PHP interpreter to parse the code
that was generated from the Slice definitions.

In this release, Slice files must be translated using a new compiler
(slice2php). This change offers several advantages:

* Applications may have more opportunities to improve performance
  through the use of opcode caching.

* It is no longer necessary to restart the Web server when you make
  changes to your Slice definitions, which is especially useful during
  development.

* Errors in your Slice files can now be discovered in your development
  environment, rather than waiting until the Web server reports a
  failure and then reviewing the server log to determine the problem.

* The development process becomes simpler because you can easily
  examine the generated code if you have questions about the API or
  language mapping rules.

* PHP scripts can now use all of the Ice local exceptions. In prior
  releases, only a subset of the local exception types were available,
  and all others were mapped to Ice_UnknownLocalException. See the
  section "Local exceptions" below for more information.

All of the Slice files for Ice and Ice services are translated during
an Ice build and available for inclusion in your application. At a
minimum, you must include the file Ice.php:

// PHP
require 'Ice.php';

Ice.php contains definitions for core Ice types and includes a minimal
set of generated files. To use an Ice service such as IceStorm,
include the appropriate generated file:

// PHP
require 'Ice.php';
require 'IceStorm/IceStorm.php';


Deployment
----------

With the transition to static code generation, you no longer need to
deploy Slice files with your application. Instead, you will need to
deploy the PHP code generated from your Slice definitions, along with
Ice.php, the generated code for the Ice core, and the generated code
for any Ice services your application might use.


Communicators
-------------

In prior releases, each PHP page request could access a single Ice
communicator via the $ICE global variable. The configuration of this
communicator was derived from the profile that the script loaded via
the Ice_loadProfile function. The communicator was created on demand
when $ICE was first used and destroyed automatically at the end of the
page request.

In this release, a PHP script must create its own communicator using
an API that is similar to other Ice language mappings:

  function Ice_initialize()
  function Ice_initialize($args)
  function Ice_initialize($initData)
  function Ice_initialize($args, $initData)

Ice_initialize creates a new communicator using the configuration
provided in the optional arguments. $args is an array of strings
representing command-line options, and $initData is an instance of
Ice_InitializationData.

An application that requires no configuration can initialize a
communicator as follows:

// PHP
$communicator = Ice_initialize();

More elaborate configuration scenarios are described in the section
"Configuration" below.

A script may optionally destroy its communicator:

// PHP
$communicator->destroy();

At the completion of a page request, Ice by default automatically
destroys any communicator that was not explicitly destroyed.


Registered communicators
------------------------

Applications may benefit from the ability to use a communicator
instance in multiple page requests. Reusing a communicator allows the
application to minimize the overhead associated with the communicator
lifecycle, including such activities as opening and closing
connections to Ice servers.

This release includes new APIs for registering a communicator in order
to prevent Ice from destroying it automatically at the completion of a
page request. For example, a session-based application can create a
communicator, establish a Glacier2 session, and register the
communicator. In subsequent page requests, the PHP session can
retrieve its communicator instance and continue using the Glacier2
session.

The Ice manual provides more information on this feature, and a new
sample program can be found in Glacier2/hello.


Configuration
-------------

Prior releases supported four INI settings in PHP's configuration
file:

  * ice.config
  * ice.options
  * ice.profiles
  * ice.slice

The ice.slice directive is no longer supported since Slice definitions
are now compiled statically. The remaining options are still supported
but their semantics are slightly different. They no longer represent
the configuration of a communicator; instead, they define property
sets that a script can retrieve and use to initialize a communicator.

The global INI directives ice.config and ice.options configure the
default property set. The ice.profiles directive can optionally
nominate a separate file that defines any number of named profiles,
each of which configures a property set.

As before, the profiles use an INI file syntax:

[Name1]
config=file1
options="--Ice.Trace.Network=2 ..."

[Name2]
config=file2
options="--Ice.Trace.Locator=1 ..."

A new directive, ice.hide_profiles, overwrites the value of the
ice.profiles directive as a security measure. This directive has
a default value of 1, meaning it is enabled by default.

A script can obtain a property set using the new function
Ice_getProperties. Called without an argument (or with an empty
string), the function returns the default property set:

// PHP
$props = Ice_getProperties();

Alternatively, you can pass the name of the desired profile:

// PHP
$props = Ice_getProperties("Name1");

The returned object is an instance of Ice_Properties, which supports
the standard Ice API.

For users migrating from an earlier release, you can replace a call to
Ice_loadProfile as follows:

// PHP - Old API
Ice_loadProfile('Name1');

// PHP - New API
$initData = new Ice_InitializationData;
$initData->properties = Ice_getProperties('Name1');
$ICE = Ice_initialize($initData);

(Note that it is not necessary to use the symbol $ICE for your
communicator. However, using this symbol may ease your migration to
this release.)

Ice_loadProfile also installed the PHP definitions corresponding to
your Slice types. In this release you will need to add 'require'
statements to include your generated code.

Finally, if you wish to manually configure a communicator, you can
create a property set using Ice_createProperties:

  function Ice_createProperties($args=null, $defaultProperties=null)

$args is an array of strings representing command-line options, and
$defaultProperties is an instance of Ice_Properties that supplies
default values for properties.

As an example, an application can configure a communicator as shown
below:

// PHP
$initData = new Ice_InitializationData;
$initData->properties = Ice_createProperties();
$initData->properties->setProperty("Ice.Trace.Network", "1");
...
$ICE = Ice_initialize($initData);


Namespaces
----------

This release includes optional support for PHP namespaces, which was
introduced in PHP 5.3. Support for PHP namespaces is disabled by
default; to enable it, you must build the Ice extension from source
code with USE_NAMESPACES=yes (see Make.rules or Make.rules.mak in
the php/config subdirectory). Note that the extension only supports
one mapping style at a time; installing a namespace-enabled version
of the extension requires all Ice applications on the target Web
server to use namespaces.

With namespace support enabled, you must modify your script to
include a different version of the core Ice types:

// PHP
require 'Ice_ns.php'; // Namespace version of Ice.php

You must also recompile your Slice files using the -n option to
generate namespace-compatible code:

% slice2php -n MySliceFile.ice

This mapping translates Slice modules into PHP namespaces instead of
using the "flattened" (underscore) naming scheme. For example,
Ice_Properties becomes \Ice\Properties in the namespace mapping.
However, applications can still refer to global Ice functions by their
traditional names (such as Ice_initialize) or by their namespace
equivalents (\Ice\initialize).


Local exceptions
----------------

As mentioned earlier, prior releases of Ice for PHP only supported a
limited subset of the standard local exceptions (refer to
Ice/LocalException.ice for the definitions of these exceptions).
An occurrence of an unsupported local exception was mapped to
Ice_UnknownLocalException.

This release adds support for all local exceptions, which allows an
application to more easily react to certain types of errors:

// PHP
try
{
    $proxy->sayHello();
}
catch(Ice_ConnectionLostException $ex)
{
    // Handle connection loss
}
catch(Ice_LocalException $ex)
{
    // Handle other errors
}

This change represents a potential backward compatibility issue:
applications that previously caught Ice_UnknownLocalException may
need to be modified to catch the intended exception instead.


Downcasting
-----------

In prior releases, to downcast a proxy you had to invoke the
ice_checkedCast or ice_uncheckedCast method on a proxy and supply
a type ID:

// PHP
$hello = $proxy->ice_checkedCast("::Demo::Hello");

This API is likely to cause run-time errors because no validation is
performed on the type ID string. For example, renaming the Hello
interface to Greeting requires that you not only change all
occurrences of Demo_Hello to Demo_Greeting, but also fix any type IDs
that your code might have embedded. The PHP interpreter does not
provide any assistance if you forget to make this change, and you will
only discover it when that particular line of code is executed and
fails.

To improve this situation, a minimal class is now generated for each
proxy type. The purpose of this class is to supply checkedCast and
uncheckedCast static methods:

class Demo_HelloPrx
{
    public static function checkedCast($proxy, $facetOrCtx=null,
                                       $ctx=null);

    public static function uncheckedCast($proxy, $facet=null);
}

Now your application can downcast a proxy as follows:

// PHP
$hello = Demo_HelloPrx::checkedCast($proxy);

You can continue to use ice_checkedCast and ice_uncheckedCast but we
recommend migrating your application to the new methods.


Other API changes
-----------------

This section describes additional changes to the Ice API in this
release:

- The global variable $ICE is no longer defined. An application must
  now initialize its own communicator as described above in the
  "Communicators" section.

- Removed the following communicator methods:

  $ICE->setProperty()
  $ICE->getProperty()

  The equivalent methods are:

  $communicator->getProperties()->setProperty()
  $communicator->getProperties()->getProperty()

- Removed the following global functions:

  Ice_stringToIdentity()
  Ice_identityToString()

  The equivalent methods are:

  $communicator->stringToIdentity()
  $communicator->identityToString()

- These functions have also been removed:

  Ice_loadProfile()
  Ice_loadProfileWithArgs()
  Ice_dumpProfile()

  Refer to the "Configuration" section above for more information.


IceSSL changes
==============

With the addition of the ConnectionInfo classes in this release (see
"New Features" above), the IceSSL::ConnectionInfo structure has
changed from a native type to a Slice class. This change has several
implications for existing applications:

* As a Slice class, IceSSL::ConnectionInfo cannot provide the X509
  certificate chain in its native form, therefore the chain is
  provided as a sequence of strings representing the encoded form
  of each certificate. You can use language-specific facilities to
  convert these strings back to certificate objects.

* For your convenience, we have added a native subclass of
  IceSSL::ConnectionInfo called IceSSL::NativeConnectionInfo. This
  class provides the certificate chain as certificate objects.

* The CertificateVerifier interface now uses NativeConnectionInfo
  instead of ConnectionInfo. If your application configures a
  custom certificate verifier, you will need to modify your
  implementation accordingly.

* In C++, also note that NativeConnectionInfo is now managed by a
  smart pointer, therefore the signature of the certificate verifier
  method becomes the following:

    virtual bool verify(const IceSSL::NativeConnectionInfoPtr&) = 0;

* The getConnectionInfo() helper function has been removed because its
  functionality has been replaced by the Connection::getInfo()
  operation. For example, in prior releases a C++ application would do
  the following:

    Ice::ConnectionPtr con = ...
    IceSSL::ConnectionInfo info = IceSSL::getConnectionInfo(con);

  Now the application should do this:

    Ice::ConnectionPtr con = ...
    IceSSL::ConnectionInfoPtr info =
        IceSSL::ConnectionInfoPtr::dynamicCast(con->getInfo());

  Alternatively, the application can downcast to the native class:
  
    Ice::ConnectionPtr con = ...
    IceSSL::NativeConnectionInfoPtr info =
        IceSSL::NativeConnectionInfoPtr::dynamicCast(con->getInfo());


================
OLD
================

Since Ice 3.3.1 maintains binary compatibility with Ice 3.3.0, it is
not necessary for you to recompile your Slice files or your program
code, nor is it necessary to relink your application. The database
formats used by Ice services such as IceGrid and IceStorm have not
changed, therefore no database migration is required. Finally, this
release has not removed or deprecated any APIs. Generally speaking,
you are free to use any combination of Ice 3.3.0 or Ice 3.3.1
applications and Ice services.

The subsections below provide additional information about upgrading
to Ice 3.3.1, including administrative procedures for the supported
platforms.


NRVO in C++
-----------

Named Return Value Optimization (NRVO) is a C++ compiler feature that
can improve the marshaling performance of Ice applications that
return large data structures. The Slice-to-C++ compiler (slice2cpp) in 
Ice 3.3.1 generates code for client-side stubs with a structure that
is slightly different than in previous Ice releases to make the code
eligible for NRVO with GNU C++ (GCC).

Note that this enhancement to the generated code in Ice 3.3.1 only
affects client-side stubs, and is only necessary to satisfy the NRVO
requirements for GCC. If you use GCC and you wish to take advantage of
this optimization in your client-side invocations, you must recompile
your Slice files as well as the resulting generated code, and then
relink your application. No action is necessary for Visual C++ users.


RPMs (Linux)
------------

For RPM installations, you can use the Ice 3.3.1 RPMs to upgrade an
existing installation of Ice 3.3.0.

For a Java application, no additional steps are necessary if your
CLASSPATH refers to /usr/share/java/Ice.jar, which is a symbolic link
that points to the actual version-specific JAR file.

For a Mono application, the ice-mono RPM for Ice 3.3.1 installs the
updated Ice run time assemblies into the Global Assembly Cache (GAC)
along with policy assemblies that enable backward compatibility with
Ice 3.3.0.


Windows
-------

The file names of the Ice for C++ run time DLLs do not contain the
patch number of a release. For example, the core Ice DLL uses the same
name (ice33.dll) for both Ice 3.3.0 and Ice 3.3.1. As a result, you
can simply substitute the 3.3.1 DLLs for the 3.3.0 DLLs. If you
install the 3.3.1 DLLs in a different directory, you will typically
need to adjust the PATH setting of a C++ application so that it can
locate the new libraries. This also applies to Python, Ruby, and PHP
applications because they use the Ice for C++ DLLs.

For a Java application, you can replace the existing Ice.jar file
with the one from Ice 3.3.1, or you can adjust the CLASSPATH setting
to point to the new JAR file.

For a .NET application, Ice for .NET includes policy assemblies that
supply the .NET run time with the required compatibility information.
Policy assemblies have names of the form policy.3.3.<package>.dll.
For example, the policy assembly for IceBox is policy.3.3.IceBox.dll.
One way to upgrade an existing .NET application to a new patch release
while maintaining binary compatibility is to install the policy
assemblies into the Global Assembly Cache (GAC) using one of the
following methods:

  - Open Windows Explorer and navigate to the directory
    C:\WINDOWS\assembly. Next, drag and drop (or copy and paste) the
    assemblies into the right-hand pane to install them in the GAC.

  - Use gacutil from the command line:

    > gacutil -i <policy.dll>

Another option is to modify the .config file of your application to
add bindingRedirect directives, as explained in the links below:

  http://msdn.microsoft.com/en-us/library/7wd6ex19.aspx
  http://msdn.microsoft.com/en-us/library/yx7xezcf.aspx

For example, in the .config file of an application you can modify the
configuration of the Ice assembly as follows:

  <dependentAssembly>
    <assemblyIdentity name="Ice" culture="neutral"
      publicKeyToken="cdd571ade22f2f16"/>
    <bindingRedirect oldVersion="3.3.0.0" newVersion="3.3.1.0"/>
    <codeBase version="3.3.1.0" href="...\Ice.dll"/>
  </dependentAssembly>

The advantage of installing the policy assemblies into the GAC is that
they establish binary compatibility for all Ice applications, whereas
modifying a .config file must be done for each application
individually.

On a development system, it is not necessary to remove your existing
Ice installation prior to installing Ice 3.3.1 unless you intend to
install Ice 3.3.1 in the same directory as your existing installation.
You may need to update your PATH setting and modify your Visual C++
directory configurations to reflect the installation directory for
Ice 3.3.1.


Binary Archives (Mac OS X, Solaris)
-----------------------------------

The README file included in each binary distribution archive
describes how to configure your environment so that the embedded
path names in the Ice for C++ shared libraries are resolved correctly.
For example, if you extracted the binary distribution for Ice 3.3.0
into /opt/Ice-3.3.0, the README file instructs you to create the
following symbolic link:

  /opt/Ice-3.3 -> /opt/Ice-3.3.0

To upgrade to Ice 3.3.1, you simply extract the binary distribution
archive into /opt/Ice-3.3.1 and reset the symbolic link to point to
the new installation:

  /opt/Ice-3.3 -> /opt/Ice-3.3.1

No additional steps are necessary for a Java application if its
CLASSPATH refers to the JAR file via the symbolic link:

  export CLASSPATH=/opt/Ice-3.3/lib/Ice.jar

This also applies for Python and Ruby applications:

  export PYTHONPATH=/opt/Ice-3.3/python
  export RUBYLIB=/opt/Ice-3.3/ruby


Source Distribution (Linux, Mac OS X, Solaris)
----------------------------------------------

If you compiled an Ice 3.3.0 source distribution and installed it via
"make install", the installation process created a symbolic link in
the target directory (/opt by default) that points to the 3.3.0
subdirectory:

  /opt/Ice-3.3 -> /opt/Ice-3.3.0

When you build and install an Ice 3.3.1 source distribution, this
symbolic link is reset to point to the 3.3.1 installation:

  /opt/Ice-3.3 -> /opt/Ice-3.3.1

If an application resolves its Ice run time via the symbolic link,
that application will automatically use the Ice 3.3.1 run time for its
next execution. The relevant environment variables for each language
mapping are detailed below.

C++, Ruby, Python, PHP:

  export LD_LIBRARY_PATH=/opt/Ice-3.3/lib (32-bit Linux & 32-bit Solaris)
  export LD_LIBRARY_PATH=/opt/Ice-3.3/lib64 (64-bit Linux)
  export LD_LIBRARY_PATH_64=/opt/Ice-3.3/lib/amd64 (64-bit Solaris Intel)
  export LD_LIBRARY_PATH_64=/opt/Ice-3.3/lib/sparcv9 (64-bit Solaris SPARC)
  export DYLD_LIBRARY_PATH=/opt/Ice-3.3/lib (Mac OS X)

Python:

  export PYTHONPATH=/opt/Ice-3.3/python

Ruby:

  export RUBYLIB=/opt/Ice-3.3/ruby

Java:

  export CLASSPATH=/opt/Ice-3.3/lib/Ice.jar

Mono:

  export MONO_PATH=/opt/Ice-3.3/bin


======================================================================
3. Upgrading your application from Ice 3.2 or earlier releases
======================================================================


Compatibility
-------------

A discussion of backward compatibility in Ice involves several
factors:

  - Source-code compatibility

    Ice maintains source-code compatibility between a patch release
    (e.g., 3.3.1) and the most recent minor release (e.g., 3.3.0),
    but we do not guarantee source-code compatibility between minor
    releases (e.g., between 3.2 and 3.3).

    Certain APIs that were deprecated in earlier Ice releases have
    been removed in Ice 3.3. Your application may no longer compile
    successfully if it relies on one of these APIs. A list of the
    removed APIs is provided in the section titled "Removed APIs"
    along with a description of their replacements. Furthermore, the
    section "Deprecated APIs" discusses APIs that are deprecated as of
    release 3.3.0; we encourage you to update your applications and
    eliminate the use of these APIs as soon as possible.

  - Binary compatibility

    As for source-code compatibility, Ice maintains backward binary
    compatibility between a patch release and the most recent minor
    release, but we do not guarantee binary compatibility between
    minor releases.

    At a minimum, you must recompile your Slice files if you use a
    Slice compiler for your language mapping. For example, in a
    statically-typed language (C++, Java, .NET) you must recompile
    your application in addition to your Slice files. In a scripting
    language (Ruby or Python), no action is necessary if you load your
    Slice files dynamically.

  - On-the-wire compatibility

    Ice always maintains protocol ("on the wire") compatibility with
    prior releases.

  - Database compatibility

    Upgrading to a new minor release of Ice often includes an upgrade
    to the supported version of Berkeley DB. In turn, this may require
    an application to migrate its databases, either because the format
    of Berkeley DB's database files has changed, or due to a change in
    the schema of the data stored in those databases.

    For example, if your application uses Freeze, it may be necessary
    for you to migrate your databases even if your schema has not
    changed.

    Certain Ice services also use Freeze in their implementation. If
    your application uses these services (IceGrid and IceStorm), it
    may be necessary for you to migrate their databases as well.

    Please refer to the relevant subsections below for migration
    instructions.

  - Interface compatibility

    Although Ice always maintains compatibility at the protocol level,
    changing Slice definitions can also lead to incompatibilities. As
    a result, Ice maintains interface compatibility between a patch
    release and the most recent minor release, but does not guarantee
    compatibility between minor releases.

    This issue is particularly relevant if your application uses Ice
    services such as IceGrid or IceStorm, as a change to an interface
    in one of these services may adversely affect your application.

    Interface changes in an Ice service can also impact compatibility
    with its administrative tools, which means it may not be possible
    to administer an Ice 3.3.x service using a tool from a previous
    minor release (or vice-versa).

    IceGrid
    -------

    Starting with Ice 3.2.0, IceGrid registries and nodes are
    interface-compatible. For example, you can use an IceGrid node
    from Ice 3.2.x with a registry from Ice 3.3.x.

    IceGrid registry replication is only supported between 3.3.x 
    releases.

    An IceGrid node from Ice 3.3.x is able to activate a server built
    with Ice 3.2.x. The reverse is also true: an IceGrid node from
    Ice 3.2.x is able to activate a server built with Ice 3.3, but
    only if the server's configuration properties do not rely on
    features from Ice 3.3 (such as the ability to escape characters
    in property names and values).

    IceStorm
    --------

    Topic linking is supported between all IceStorm versions released
    after 3.0.0.


Migrating IceStorm databases
----------------------------

Ice 3.3 supports the migration of IceStorm databases from Ice 3.1 and
from Ice 3.2. Migration from other Ice versions may work, but is not
officially supported. If you require assistance with such migration, 
please contact support@zeroc.com.

To migrate, first stop your IceStorm servers.

Next, copy the IceStorm database environment to a second location:

$ cp -r db recovered.db

Run the Berkeley DB utility db_recover on the copied database
environment:

$ db_recover -h recovered.db

Note that it is essential that the correct version of db_recover is
used. For Ice 3.1, Berkeley DB 4.3.29 must be used. For Ice 3.2,
Berkeley DB 4.5 must be used.

Now change to the location where the Ice 3.3 IceStorm database
environments are stored:

$ cd <new-location>

Next, run the icestormmigrate utility. The first argument is the path
to the old database environment. The second argument is the path to
the new database environment.

In this example we'll create a new directory "db" in which to store
the migrated database environment:

$ mkdir db
$ icestormmigrate <path-to-recovered.db> db

The migration is now complete, and the contents of the old database
environment are now in the "db" directory.


Migrating IceGrid databases
---------------------------

Ice 3.3 supports the migration of IceGrid databases from Ice 3.1 and
from Ice 3.2. Migration from other Ice versions may work, but is not
officially supported. If you require assistance with this please
contact sales@zeroc.com.

To migrate, first stop the IceGrid registry you wish to upgrade.

Next, copy the IceGrid database environment to a second location:

$ cp -r db recovered.db

Run the Berkeley DB utility db_recover on the copied database
environment:

$ db_recover -h recovered.db

Note that it is essential that the correct version of db_recover is
used. For Ice 3.1, Berkeley DB 4.3.29 must be used. For Ice 3.2,
Berkeley DB 4.5 must be used.

Now change to the location where the Ice 3.3 IceGrid database
environments are stored:

$ cd <new-location>

Next, run the upgradeicegrid.py utility located in the `config'
directory of your Ice distribution (or in /usr/share/Ice-3.3.1 if
using an RPM installation). The first argument is the path to the old
database environment. The second argument is the path to the new
database environment.

In this example we'll create a new directory "db" in which to store
the migrated database environment:

$ mkdir db
$ upgradeicegrid.py <path-to-recovered.db> db

The migration is now complete, and the contents of the old database
environment are now in the "db" directory.

By default, the migration utility assumes that the servers deployed
with IceGrid also use Ice 3.3. If your servers still use an older Ice
version, you need to specify the --server-version command-line option
when running upgradeicegrid.py:

$ upgradeicegrid.py --server-version 3.2.1 <path-to-recovered.db> db

The migration utility will set the server descriptor `ice-version'
attribute to the specified version and the IceGrid registry will
generate configuration files compatible with the given version.

If you are upgrading the master IceGrid registry in a replicated
environment and the slaves are still running, you should first restart
the master registry in read-only mode using the --readonly option, for
example:

$ icegridregistry --Ice.Config=config.master --readonly

Next, you can connect to the master registry with icegridadmin or the
IceGrid administrative GUI to ensure that the database is correct. If
everything looks fine, you can shutdown and restart the master
registry without the --readonly option.


Migrating Freeze Databases
--------------------------

There is no special Freeze procedure or Freeze tool to perform this
upgrade. Freeze still stores exactly the same data, in the same
format.

However, we upgraded the version of Berkeley DB, and as a result when
upgrading from Ice 3.2 to Ice 3.3, you have to upgrade your database
from the "Berkeley DB 4.5" format to the new "Berkeley DB 4.6" format.

This is fortunately straightforward, since the only relevant format
change for Freeze was the log format change.

From the Berkeley DB Upgrade Process:

 http://www.oracle.com/technology/documentation/berkeley-db/db/ref/upgrade/process.html

If the application has a Berkeley DB transactional environment, and
the log files need upgrading but the databases do not, the application
may be installed in the field using the following steps:

 1. Shut down the old version of the application.

 2. Still using the old version of Berkeley DB, run recovery on the
    database environment using the DB_ENV->open method or the
    db_recover utility.

 3. If you used the DB_ENV->open method to run recovery, make sure
    that the Berkeley DB environment is removed using the
    DB_ENV->remove method or an appropriate system utility.

 4. Archive the database environment for catastrophic recovery.
    See Archival procedures for more information.

 5. Recompile and install the new version of the application.

 6. Force a checkpoint using the DB_ENV->txn_checkpoint method or the
    db_checkpoint utility. If you use the db_checkpoint utility, make
    sure to use the new version of the utility; that is, the version
    that came with the release of Berkeley DB to which you are
    upgrading.

 7. Restart the application.

We recommend that you use the Berkeley DB utilities rather than
writing your own database migration program.


Removed APIs
------------

Release 3.3.0 removed a number of APIs. These APIs are no longer
available.

* Thread per connection

  The primary purpose of this concurrency model was to serialize the
  requests received over a connection, either because the application
  needed to ensure that requests are dispatched in the order they are
  received, or because the application did not want to implement the
  synchronization that might be required when using the thread pool
  concurrency model.

  Another reason for using the thread-per-connection concurrency model
  is that it was required by the IceSSL plug-ins for Java and C#. This
  requirement has been eliminated.

  The ability to serialize requests is now provided by the thread pool
  and enabled via a new configuration property:

  <threadpool>.Serialize=1

  Please refer to the "Ice Run Time" chapter of the Ice manual for
  more details on this feature.

  Aside from the potential semantic changes involved in migrating your
  application to the thread pool concurrency model, other artifacts of
  thread-per-connection may be present in your application and must be
  removed:

  - The configuration properties Ice.ThreadPerConnection and
    <proxy>.ThreadPerConnection

  - The proxy methods ice_threadPerConnection and
    ice_isThreadPerConnection

* .NET metadata

  The metadata directive "cs:collection" is no longer valid. Use
  ["clr:collection"] instead.

* C++

  The following methods have been removed:

  - Application::main(int, char*[], const char*, const Ice::LoggerPtr&)

    Use Application::main(int, char*[], const InitializationData&)
    instead.

  - initializeWithLogger
  - initializeWithProperties
  - initializeWithPropertiesAndLogger

    Use initialize(int, char*[], const InitializationData&) instead.

  - stringToIdentity
  - identityToString

    Use the equivalent Communicator operations.

* Java

  The following methods have been removed:

  - Application.main(String, String[], String, Logger)

    Use Application.main(String, String[], InitializationData)
    instead.

  - initializeWithLogger
  - initializeWithProperties
  - initializeWithPropertiesAndLogger

    Use initialize(String[], InitializationData) instead.

* .NET

  The following methods have been removed:

  - Application.main(string, string[], string, Logger)

    Use Application.main(string, string[], InitializationData)
    instead.

  - initializeWithLogger
  - initializeWithProperties
  - initializeWithPropertiesAndLogger

    Use initialize(ref string[], InitializationData) instead.

* Python

  The following methods have been removed:

  - initializeWithLogger
  - initializeWithProperties
  - initializeWithPropertiesAndLogger

    Use initialize(args, initializationData) instead.

  - stringToIdentity
  - identityToString

    Use the equivalent Communicator operations.

* General

  The following methods have been removed:

  - ice_hash
  - ice_communicator
  - ice_collocationOptimization
  - ice_connection

    These proxy methods were replaced by ones of the form ice_get...,
    such as ice_getHash. ice_collocationOptimization is now
    ice_getCollocationOptimized.

  - ice_newIdentity
  - ice_newContext
  - ice_newFacet
  - ice_newAdapterId
  - ice_newEndpoints

    These proxy methods were replaced by ones that do not use "new" in
    their names. For example, ice_newIdentity was replaced by
    ice_identity.

* Ice.LoggerPlugin

  This property provided a way to install a custom logger
  implementation. It has been replaced by a more generalized facility
  for installing custom loggers.


Deprecated APIs
---------------

The Ice APIs and components listed below are deprecated. We encourage
you to update your applications and eliminate the use of these APIs as
soon as possible.

* Java2 language mapping

  Java5 is now the default language mapping. Applications that use the
  Java2 mapping can continue to use it by adding the appropriate
  metadata tag to your Slice files or by using the "--meta java:java2"
  option when running the Slice-to-Java compiler. Note that the
  compiler now emits a deprecation warning when it encounters the
  Java2 metadata tag.

  If you used the "java:java5" metadata tag when compiling your Slice
  definitions, you can now remove those tags. Any uses of custom type
  metadata ("java:type:...") should also be reviewed.

* Sequences as dictionary keys

  The use of sequences, and structures containing sequences, as the
  key type of a Slice dictionary is now deprecated.

* LocalObject

  The mappings for the LocalObject type have changed in Java, .NET and
  Python. The new mappings are shown below:

  Java    java.lang.Object
  .NET    System.Object
  Python  object

  The types Ice.LocalObject and Ice.LocalObjectImpl are deprecated.

* Ice.Trace.Location

  This property has been replaced by Ice.Trace.Locator.

* Ice.Default.CollocationOptimization

  This property, as well as the corresponding proxy property, have
  been replaced by Ice.Default.CollocationOptimized and
  <proxy>.CollocationOptimized, respectively.

* <Adapter>.RegisterProcess

  This property caused the Ice run time to register a proxy with the
  locator registry (e.g., IceGrid) that allowed the process to be shut
  down remotely. The new administrative facility (see "New Features")
  has replaced this functionality.

* Ice.ServerId

  As with <Adapter>.RegisterProcess, this property was used primarily
  for IceGrid integration and has been replaced by a similar mechanism
  in the administrative facility (see "New Features").

* Glacier2.Admin
  IcePatch2.Admin

  These are the names of administrative object adapters in Glacier2
  and IcePatch2, respectively. The functionality offered by these
  object adapters has been replaced by that of the administrative
  facility (see "New Features"), therefore these adapters (and their
  associated configuration properties) are deprecated.


======================================================================
4. Platform-specific notes
======================================================================


Supported platforms
-------------------

This release supports the operating systems, compilers, and run-time
environments listed in the link below:

  http://www.zeroc.com/platforms_3_3_1.html


Java and IPv6
-------------

IPv6 is not currently supported in Java on Windows due to a bug in the
JVM. Refer to the bug database for more information:

  http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6230761


Mono
----

Mono requires that a system's host name be correctly configured and
that it resolves to an IP address. Otherwise, Mono is unable to
determine the local IP addresses, which causes the creation of object
adapters that listen on INADDR_ANY/0.0.0.0 to fail with an
Ice::DNSException.

Note that SLES 10 SP1 includes Mono 1.2.2, which does not support
IPv6 multi-cast. If you want to use this feature, you need to upgrade
to Mono 1.2.6 or later. To upgrade to a more recent version
of Mono please follow the directions at:

    http://www.go-mono.com/mono-downloads/download.html


Red Hat Enterprise Linux 5.1
----------------------------

On Red Hat Enterprise Linux 5.1 systems, Ice connection establishment
to an inactive port of an IPv6 interface might hang instead of
immediately reporting "connection refused" (ECONNREFUSED). The hang
can last for several minutes and is similar to hangs you would get if
you try to connect to an unreachable address. This is a RHEL 5.1
kernel issue which has been fixed in the RHEL 5.2 kernel.

Refer to https://bugzilla.redhat.com/show_bug.cgi?id=248052 for more
information.


IBM JDK
--------

The IBM JDK ships with limited jurisdiction policy files for the
cryptographic libraries. This creates an issue for Ice's certificate
authority script (iceca) when running with the command-line options
"iceca java --import". The import fails with an error similar to:

  "java.lang.SecurityException: Unsupported keysize or algorithm
  parameters"

To solve this problem you must install the unlimited jurisdiction
policy files. For more information, including a link to download
the policy files, see:

  http://www.ibm.com/developerworks/java/jdk/security/50/

Once you have downloaded the policy files, you must unpack them into
the jre/lib/security directory.


======================================================================
5. Known Problems
======================================================================


Slice-to-HTML
-------------

slice2html generates incorrect code for some legal constructs. The
problem is caused by bug in the mcpp preprocessor. For example:

module M
{
    class SomeClass; // Forward declaration. mcpp loses this.

    struct SomeStruct
    {
        SomeClass* proxy;
    };
};

The mcpp bug causes the forward declaration to be lost, resulting in
an undefined symbol error for the proxy member. To work around this
issue, you can move the trailing comment onto a separate line:

module M
{
    // Forward declaration. This works.
    class SomeClass;

    struct SomeStruct
    {
        SomeClass* proxy;
    };
};

Or you can use a C-style comment:

module M
{
    class SomeClass; /* Forward declaration. This works. */

    struct SomeStruct
    {
        SomeClass* proxy;
    };
};


UNC Paths and Slice compilers
-----------------------------

The Slice compilers currently do not support the use of UNC paths in
include directories. For example, the following does not work:

  slice2cpp -I\\MACHINE\SliceFiles Test.ice

The compiler will report errors indicating it cannot find any of the
files from \\MACHINE\SliceFiles that were included by Test.ice. This
limitation is caused by a bug in the mcpp preprocessor.


C++Builder 2009 Bugs
--------------------

C++Builder 2009 (BCC) suffers from several bugs that required us to
devise workarounds in Ice and may affect Ice for C++ applications as
well.

This bug is the most likely to affect an application:

  http://qc.embarcadero.com/wc/qcmain.aspx?d=71611

If you have a call within a try/catch that returns an object, the
destructor for that object is called even though the object is not
constructed.

Here is a simple example that would be common in an Ice application:

   Ice::ObjectPrx proxy;
   try
   {
       proxy = communicator->stringToProxy("...");
   }
   catch(const ProxyParseException&)
   {
   }

If stringToProxy throws an exception, C++Builder 2009 tries to
destruct an Ice::ObjectPrx object that was never constructed, leading
to an access violation and a program crash.

This problem only occurs if there are no other objects that have a
defined destructor declared on the stack inside the try/catch block.
Therefore, the workaround is to add such an object declaration. For
example, you can define a simple class with a destructor and allocate
an instance of that class on the stack in each try/catch block.

Here is the second run time bug:

  http://qc.embarcadero.com/wc/qcmain.aspx?d=69968

If a constructor throws an exception, the destructor of class members
can sometimes be called twice. A workaround is to add an initialize
method to the class, move code that might throw an exception from the
constructor to the initialize method, and invoke initialize
immediately after the constructor.

Here is another run time bug:

  http://qc.embarcadero.com/wc/qcmain.aspx?d=71689

The destructor for a stack-allocated object inside a catch block can
be called twice if you are inside a loop and call continue from within
the catch block. The workaround is to ensure that the destructors of
any stack-allocated objects are executed before you call continue.
