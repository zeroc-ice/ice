Changes since version 2.0.0
---------------------------

- Added ice_ping optimization in the Freeze evictor: for operation
  "ice_ping", the object is not loaded in the cache, Freeze only
  checks if the object is in the cache or the database.

- Fixed a slice2cpp failure when the --output-dir option specified a
  directory containing backslashes.

- Changed the signature of Ice::Service::main() and Ice::Service::run()
  to accept a reference to argc (int & argc) rather than passing argc
  by value (int argc). This is to ensure that, if Ice::initialize() or
  Ice::Service::initializeCommunicator() rewrites argv, argc reflects
  the number of elements of the rewritten argument vector.

- Fixed an encoding bug in IceSSL.

- Fixed incorrect logging message if no more endpoints are available
  for retry.

- Added setDefaultContext() and getDefaultContext() to the
  Ice::Communicator interface. This allows a default context to be
  established on a communicator-wide basis. See section 29.8.3 in the
  doc.

  Added ice_defaultContext to Ice::ObjectProxy. This creates a new
  proxy that uses the default context established on the communicator.

- Fixed a rare proxy marshaling bug that could cause the receiver to
  encounter an UnmarshalOutOfBoundsException.

- Overloaded the checkedCast member function of the generated Prx
  classes to allow a trailing argument of type ::Ice::Context. This
  makes it possible to do stateful things that require a context in a
  servant locator's activate() method.

- Added catalogs for Freeze: each database environment used by Freeze
  now contains a special dictionary (named __catalog) that keeps track
  of all evictor and dictionary databases in this environment.

- Fixed a bug in slice2cs and slice2vb: incorrect code was generated
  if an interface was derived from a base interface in a different
  module and if the base interface contained an AMD operation.

- Changed IceUtil::GCShared to derive from IceUtil::Shared.
  (Previously, these two classes were unrelated.) This change allows
  servants to be derived from IceUtil::Thread, which was impossible
  previously.

Changes since version 1.5.1
---------------------------

- Fixed a bug in IcePack which could cause a core dump of the IcePack
  registry or node when updating an application deployment.

- The proxy returned by the object adapter operations addFacet and
  addFacetWithUUID did not contain the facet. This required the
  application to make an extra call to ice_newFacet in order to
  obtain the correct proxy. This has been fixed.

- Added the object adapter property <name>.PublishedEndpoints, which
  specifies endpoints to advertise in proxies created by the adapter.

- For WIN32, Thread::getThreadControl() set the thread id of the
  ThreadControl object to the current thread instead of the thread the
  control object belongs to. This has been fixed.

- Changed Ice::Service to use _exit() in the daemon parent.

- Fixed a bug with AMD exception handling, where it was possible that
  certain exceptions propagate out of ice_response() or
  ice_exception(), and therefore such exceptions were not handled
  properly.

- Exceptions raised while marshaling data for batch requests resulted
  in a connection deadlock. This has been fixed.

- Fixed a bug in slice2cs: the generated code was incorrect for
  dictionaries with sequence value types, if that sequence value type
  was mapped to an array.

- Fixed bug in IcePack that would prevent dynamically added adapters
  from being used again after the IcePack registry was restarted.

- Fixed tracing of operation mode.

- Fixed bug in slice2cpp: for statically linked binaries under
  Windows, exceptions and classes could cause an
  UnmarshalOutOfBoundsException.

- Fixed bug in slice2java: with the --impl-tie option, incorrect code
  was generated for local interfaces and classes.

- Tightened semantic check for all Slice compilers: previously, a
  local interface or class could be derived from a non-local interface
  or class. This is now correctly diagnosed as an error.

- Changed code generation in slice2java: for local interfaces, only an
  OperationsNC (but no Operations) interface is generated
  now. (Previously, both interfaces were generated, with one of them
  being empty.)

- The IceSSL plug-in was using regular mutexes in some places where
  static mutexes are necessary. This has been fixed.

- Fixed a bug in the garbage collector that caused a crash in rare
  circumstances.

- Freeze dictionaries now support indices. You can index on the full
  value of the dictionary, or on a member (when the value is a struct
  or a class). When you index on a member, you can define several
  indices (for different members). See the Freeze bench demo and the
  Freeze dbmap test for examples.

- The Ice::Service class no longer resets the umask to 0, but rather
  uses the inherited umask.

- Fixed a code generation problem in slice2cpp. This problem showed up
  only for the --impl option.

- Changed the way C++ keywords are escaped. Previously, a Slice
  identifier that is a C++ keyword was escaped everywhere. For
  example, Slice "while" was mapped to "_cpp_while" and
  "_cpp_whilePrx". With the change, Slice "while" is mapped to
  "_cpp_while" and "whilePrx".

- Fixed the slice2java and slice2cs compilers for operations with
  multiple exceptions in an exception specification: if an exception
  was a base of one or more other exceptions in the same exception
  specification, the code generator sometimes emitted the catch blocks
  in the marshaling and dispatch code in the wrong order. (This
  applied only to interfaces with an ["amd"] metadata directive.)

- Fixed a bug in the slice2cs code generator:
  
  ["cs:collection"] sequence<Object> S1;
  ["cs:collection"] sequence<Object*> S2;

  Sequences of Object or Object* caused incorrect code to be generated
  if they were marked as "cs:collection".

- Fixed a bug in the slice2cs code generator: for nested sequences,
  incorrect code was generated if both the inner and the outer
  sequence were mapped as arrays.

- Fixed a number of bugs in slice2cs that caused incorrect code to be
  generated if C# keywords were used as Slice identifiers.

- Fixed a bug in slice2cpp that permitted impossible exceptions to be
  received by a client if client and server used Slice definitions
  with mismatched exception specifications. The client now correctly
  receives UnknownUserException if the server throws an exception
  that, according to the client's view of the operation, is
  impossible.

- The documentation has always stated that same-named constructs
  cannot be directly nested inside each other. (For example, a module
  `M' cannot contain a constant named `M'.) The Slice compilers did
  not enforce this correctly up to now for modules containing
  constructs with the same name as the enclosing module.  This has
  been fixed and now results in a diagnostic.

- The slice2cpp compiler now deprecates Slice definitions at global
  scope: only modules can be defined at global scope. Everything else
  (constants, classes, interfaces, etc.) must be defined inside a
  module.

  For the time being, the compiler issues a warning for each global
  definition but continues to compile the code. Global non-module
  definitions will elicit a hard error two releases from now.

- Several demos used Slice classes where interfaces were more
  appropriate. This has been fixed.

- Fixed a bug in the Windows IcePack registry project that would cause
  a compilation error if the registry was compiled before the node.

- Fixed a hang in the IcePack registry that would occur if multiple
  nodes were started simultaneously.

- Added new properties Ice.StdErr and Ice.StdOut to redirect the
  standard error and output streams of a process. Reimplemented
  IcePack's error/output redirection using these properties.

Changes since version 1.5.0
---------------------------

- The relevant Windows project files were fixed to generate Slice
  checksums.

- Fixed harmless warnings emitted by the IcePatch client.

- Fixed a bug in IceStorm that caused a subscriber to no longer
  receive events after unsubscribing and resubscribing to the same
  topic.

- Fixed a bug in the slice2cs code generator: classes with multiple
  sequence members caused incorrect code to be generated.

- Added work-around for clients "hanging" at exit when using IcePack
  on Windows.

Changes since version 1.4.0
---------------------------

- Added support for generating checksums of Slice definitions,
  enabling peers to verify that they share the same client-server
  contract. See the manual for more information.

- Fixed a bug that could cause an assert or exception in some rare
  circumstances, if an operation is invoked after the object adapter
  for the Ice object has been deactivated.

- Fixed a bug in the C++ translator that caused compile errors when
  two Slice classes with the same name appeared in different modules
  in the same file.

- Changed the names of Windows executables to lower case, for
  consistency with non-Windows platforms. The following executables
  have been renamed:

    DumpDB.exe		-> dumpdb.exe
    GlacierRouter.exe	-> glacierrouter.exe
    GlacierStarter.exe	-> glacierstarter.exe
    IcePackNode.exe	-> icepacknode.exe
    IcePackRegistry.exe	-> icepackregistry.exe
    IcePatchCalc.exe	-> icepatchcalc.exe
    TransformDB.exe	-> transformdb.exe

  All library names have also been renamed accordingly.

- Changed the default behavior of the IcePatch client to dynamically
  calculate the unique signatures of local files in order to reduce
  the number of cache files, and added the property IcePatch.Dynamic
  to control this behavior.

- AIX 5.2/VisualAge 6.0 port.

- Changed the --depend option of slice2java. If you get dependencies
  for a file x.ice that includes y.ice, the dependency line that is
  written now is "x.ice: y.ice". (Previously, it was "x.cpp: x.ice
  y.ice".) If a Slice file does not include any other Slice file, no
  dependency is printed. With some post-processing, this is sufficient
  to generate dependencies for tools such as ant and make.

- Removed IceBox::ServiceBase and IceBox::FreezeService. There's now a
  single IceBox::Service interface.

- IcePack descriptors have been redesigned. See the manual for more
  information on the new descriptor format.

- Some IcePack improvements:
  
  * Descriptors are now parsed only by the icepackadmin tool,
    therefore it is no longer necessary to store the descriptor files
    on each IcePack node or registry host.
  
  * It is now possible to update an application or server deployment
    by modifying its XML descriptor and using the `application update'
    or `server update' commands in icepackadmin.

  * It is now possible to define variables from the icepackadmin
    command line when deploying or updating an application or server.

  * An icepackadmin `node remove' command has been added to clean up
    resources associated with a given node.

  * A command line option `--checkdb' has been added to the
    icepacknode executable. When the node is started with this option,
    it performs a consistency check on its database to remove servers
    that are no longer registered with the IcePack registry.

Changes since version 1.3.0
---------------------------

- Added a fix to the mutex tests in test/IceUtil/thread for FreeBSD.

- Modified the Ice::Service class to support the Ice.Nohup property,
  rename the win9x function to checkSystem, and add more flexibility
  in configuring services. See the reference manual for more
  information.

- Added unsupported FreeBSD port.

- Ice now builds with GCC 3.4.0.

- Fixed a bug when making asynchronous invocations on a routed proxy.

- Removed slice2wsdl.

- Changed the way sequences are unmarshaled to protect against
  malicious messages with faked very large sequence count values.
  While even with previous versions of Ice, buffer overruns were
  impossible, malicious messages could cause large amounts of memory
  to be preallocated, causing the receiving process to run out of
  memory. This is no longer possible -- the total amount of memory
  preallocated for sequences during unmarshaling is now capped at
  Ice.MessageSizeMax.

- Freeze Evictor changes to adapt to the facet redesign, and 
  make several improvements:
  
  * The Freeze Evictor now has add, addFacet, remove and removeFacet
    operations with the same signature and behavior as the Ice
    ObjectAdapter.

  * The createObject and destroyObject operations were kept for 
    compatibility with Ice 1.2/1.3, but are now deprecated.

  * getIterator now takes a facet parameter, and no longer takes
    a loadServants parameter.

  * Indices can now be defined for facets (not just the "" facet).
 
  * The ServantInitializer initialize operation now takes a facet
    parameter. 

  * The ServantInitializer is now provided to the Evictor in the
    createEvictor call. In this way, the Evictor can consider the
    servant initializer immutable and avoid locking.

  * Servant initialization is now performed without holding any
    Evictor locks. As a result, a servant initializer can perform
    any remote call, except one that comes back to the object
    being initialized (which would result in a deadlock).

  * The Evictor is now associated with a single object adapter;
    this object adapter is provided in the createEvictor call.

  * The Evictor is now "deactivate-safe": if you deactivate the
    evictor while other threads are performing other Evictor 
    operations, deactivate() will wait until these operations
    have completed.

  * The new keep and release operations let you lock and unlock 
    an object in an Evictor's cache.

- Removed a bogus assert that could happen under certain race
  conditions when a connection timeout occurs.

- Facets have been significantly redesigned.

  * Facets are no longer hierarchical. As a result, FacetPath (which
    was a sequence of strings) is now simply a string. This is
    reflected in all APIs that used FacetPath.

  * There is no longer an active facet map in Ice::Object. As a
    result, the following operations have been removed:

    + On proxies: ice_facets, ice_appendFacet.

    + On Object: ice_facets, ice_addFacet, ice_removeFacet,
      ice_updateFacet, ice_removeAllFacets, ice_findFacet,
      ice_findFacetPath.

  * The object adapter is now used to register facets instead of the
    active facet map. The following operations have been added to
    Ice::ObjectAdapter: addFacet, addFacetWithUUID, removeFacet,
    removeAllFacets, findFacet, and findAllFacets.

    Please see the reference manual for more information. For naming
    consistency, the following object adapter operations have been
    renamed:

    + identityToServant has been renamed to find.
    + proxyToServant has been renamed to findByProxy.

  * This object model design change means that facets are no longer
    transferred with an object sent by value.

  * If your application receives an object with facets from an older
    version of Ice, a MarshalException is raised. This is unavoidable
    because it is a change to the object model, and not just to the
    way objects are transferred or encoded.

  * If your application receives a request or reply with a facet path
    with more than one element, the run time throws a MarshalException.

  * If your application receives a proxy with a facet path with
    more than one element, the run time throws ProxyUnmarshalException.

- Ice no longer retries operation calls on RequestFailedException.
  (ObjectNotExistException, OperationNotExistException, and
  FacetNotExistException are derived from RequestFailedException.)

- Fixed link errors when building Ice without BerkeleyDB in the
  shared library search path.

- Added ConnectionRefusedException as a specialization of
  ConnectFailedException, to indicate if a connection fails because a
  server actively refuses the connection.

- The documentation claimed that the Ice.ProgramName property was
  initialized to the value of argv[0], but that initialization was in
  fact not happening. As of this version, Ice.ProgramName is
  initialized correctly.

- Fixed the slice2cpp compiler for operations with multiple exceptions
  in an exception specification: if an exception was a base of one or
  more other exceptions in the same exception specification, the code
  generator sometimes emitted the catch blocks in the marshaling and
  dispatch code in the wrong order.

Changes since version 1.2.0
---------------------------

- Added FreezeScript, which consists of the tools dumpdb and
  transformdb for inspecting and migrating Freeze databases,
  respectively.

- The IceStorm server now uses a single database for all topics,
  which makes topic creation much faster.

- Added the virtual member functions ice_preMarshal and
  ice_postUnmarshal to Ice::Object. The default implementations do
  nothing, but subclasses may override them to take special action
  before marshaling and after unmarshaling, respectively.

- Added the demo/IcePack/simple example.

- Fixed a bug in IcePack that could cause the node to crash if a
  server failed to start.

- IceBox services deployed with IcePack are now loaded in the order
  they appear in the XML IceBox descriptor.

- Connections are no longer closed when the last proxy using the
  connection is destroyed. Doing so is error prone:

  * Quite often, proxies are created on the fly, resulting in
    connections being opened and closed all the time. This is
    especially true for services that receive a proxy and data, and
    then forward this data using the proxy.

  * Often, connections are stay open for too long, because proxies are
    kept even though they are never used again.

  * It doesn't work well with AMI requests, because the AMI callback
    objects keep track of connections directly. This would mean that
    if a process only uses AMI requests, a connection is opened and
    closed for each request, as each request typically has its own
    AMI callback object.

  Instead, ACM (Automatic Connection Management) is now enabled by
  default, with a default value of one minute. This means that idle
  connections are closed after one minute, regardless of whether there
  are proxies using the connection or not. This closing of connections
  is transparent, i.e., closed connections are automatically
  reestablished in case they are needed again. Please see the
  description of the Ice.ConnectionIdleTime property for details.

- ACM has been completely reworked. It now works properly with respect
  to retrying failed requests.

- Added the IceSSL.Client.IgnoreValidPeriod and
  IceSSL.Server.IgnoreValidPeriod properties. See the description in
  the manual for details.

- Added the IceBox.LoadOrder property, which specifies the order
  in which IceBox services are loaded.

- Added support for the Intel C++ compiler (v8.0) on Linux x86.

- Removed the Ice.Daemon, Ice.DaemonNoChdir and Ice.DaemonNoClose
  properties. Support for Unix daemons and Win32 services has been
  integrated into the Ice::Service class.

- The default thread pool size is now just one thread. This is the
  fastest possible setting, still allows one level of nesting, and
  doesn't require that servants be thread safe. (Please see the
  description of the thread pool properties in the manual for
  information on how to increase the number of threads.)

- HP-UX port. See INSTALL.HP-UX.

- Added extra file integrity checks to IcePatch::Client.

- Fixed a problem with servers not shutting down properly under
  certain circumstances.

- IceUtil::Thread now calls srand() in each new thread (Windows only).

- When unmarshaling a string sequence parameter, Ice was not clearing
  the vector before appending elements to it. This has been fixed.
  
- Fixed a rare connection deadlock, that could happen if lots of long
  messages are sent rapidly in parallel, using separate threads or
  AMI.

- Fixed a race condition that could lead to a deadlock if a thread
  tried to join with another thread from within the destructor of a
  servant or class.

- Added support for IcePack and Glacier on Windows platforms.
  The IcePack Registry, IcePack Node and Glacier Starter programs
  can optionally be installed as Windows services. See the Ice
  manual for more information.

- Added a new logger implementation that uses the Windows Event Log.
  To use it, set the Ice.UseEventLog property to a non-zero value.

- Three new icepackadmin commands:

  * server signal NAME SIGNAL

    Causes the IcePackNode to send a signal to a server. (Unix only)

  * server stdout NAME MESSAGE

    Writes MESSAGE on server's stdout.

  * server stderr NAME MESSAGE

    Writes MESSAGE on server's stderr.

- Two new IcePack.Node properties:

  * IcePack.Node.Output=<path>

    If set, the IcePack node will redirect the stdout and stderr 
    output of the started servers to files named <server>.out and 
    <server>.err in this directory. Otherwise, the started servers 
    share the stdout and stderr of the IcePack node.

  * IcePack.Node.RedirectErrToOut=<num>

    If <num> is set to a value larger than zero, the stderr of each
    started server is redirected to the server's stdout.

- Added Slice interface Ice::Process in slice/Ice/Process.ice. This
  interface enables IcePack to properly shut down a process without
  relying on signals, which is necessary for successful operation
  on Windows.

- Added setServerProcessProxy to Ice::LocatorRegistry.

- Added new properties <ObjectAdapter>.RegisterProcess and
  Ice.ServerId. If RegisterProcess is defined, the object adapter
  creates a servant implementing the Ice::Process interface and
  registers it with the locator registry using the server id
  defined by Ice.ServerId.

- Added the "register" attribute to the <adapter> element in the
  IcePack descriptors. If true, the RegisterProcess property is
  defined for the object adapter.

- Added getLocator to ObjectAdapter.

- Eliminated Glacier's dependency on the crypt library. It now
  uses an equivalent function from OpenSSL.

- Fixed a bug that could cause a crash if an application used
  Ice::Application and was interrupted by a signal, resulting
  in two calls to Communicator::destroy().

- Replaced interface Glacier::PasswordVerifier with
  Glacier::PermissionsVerifier, property
  Glacier.Starter.PasswordVerifier with
  Glacier.Starter.PermissionsVerifier, and changed
  Glacier::Starter::startRouter() to throw PermissionDeniedException
  instead of InvalidPasswordException.

- Fixed a problem with the random selection of SSL endpoints.

- Ice is now supported on Windows 98 SE. See INSTALL.WINDOWS.

- Fixed an incorrect complaint in the Slice parser about a change of
  meaning for enumeration constant definitions.

- The glacierrouter and glacierstarter processes used to abort if
  given a non-existent config file.

- Changed Ice::Exception::ice_name() to return const std::string&
  instead of returning a string by value.

- Added support for "global" metadata, which can only be specified
  once in a file and must appear before any definitions. The syntax
  is similar to that of local metadata, but with an extra set of
  brackets: [["metadata1","metadata2","etc."]]. The first use of this
  metadata is for specifying a package in Java.

- The IcePatch server no longer changes the working directory.
  This avoids potential problems with core files being generated in
  the data directory.

- Ice now uses gethostbyname_r() if available.

- Errors during close() or shutdown() on connections now cause
  exceptions.

- Fixed a deadlock that could happen if requests were sent from the
  exception() AMI callback.

- Eliminated the need to define _UNICODE when building Ice on Windows.

- Fixed problems with generated code in slice2cpp and slice2freeze
  when --header-ext is used.

- The Slice parser and database transformer didn't parse negative
  floating-point numbers correctly. This has been fixed.

- If the Glacier Starter couldn't start the Glacier Router, the
  starter terminated. This has been fixed.

- Visual C++ 7.x builds can now be used by applications built with 
  /Zc:wchar_t.

- Fixed a bug in IceSSL that caused the error message "WRN unable
  to load certificate authorities" to be logged when no value
  was specified for the "path" attribute of <certauthority>.

- Added property Ice.Override.ConnectTimeout. See the manual for
  details.

- Fixed a rare deadlock in the object adapter, when a locator was
  used.

- Fixed a bug that could cause an abort if communicators were created
  and destroyed in rapid succession.

- Fixed transformdb to take separate arguments for specifying
  include paths. The option -I has been replaced with the options
  --include-old and --include-new.

- Added twoway-throttling to Glacier. See the descriptions of the
  properties Glacier.Router.Client.Throttle.Twoways and
  Glacier.Router.Server.Throttle.Twoways for details. To trace
  throttling, set the property Glacier.Router.Trace.Throttle.

- The properties Glacier.Router.Client.BatchSleepTime and
  Glacier.Router.Server.BatchSleepTime have been replaced with
  Glacier.Router.Client.SleepTime and Glacier.Router.Server.SleepTime.
  Please see the description of the properties in the manual for the
  new semantics of the sleep times.

- Added STL functors for partial proxy comparison:

  * ProxyIdentityLess
  * ProxyIdentityEqual
  * ProxyIdentityAndFacetLess
  * ProxyIdentityAndFacetEqual

- A DNSException could cause a deadlock. This has been fixed.

- Changed FD_SETSIZE under Windows to 1024. (The default permits only
  64 concurrent connections, which is too small for some applications.)

- The IcePatch server now ignores Ice exceptions in the update thread
  instead of terminating the update thread.

- Fixed a concurrency bug that could cause the IcePack registry to
  crash.

Changes since version 1.1.1
---------------------------

- Added a garbage collector for class graphs that form cycles. (See
  the C++ mapping chapter in the documentation for details.)

- Manual retry in the exception() callback of asynchronous requests
  didn't work. This has been fixed.

- Fixed a crash that could happen during shutdown.

- Fixed a deadlock that could happen during connection establishment.

- Fixed deadlock during shutdown that can happen if a thread pool with
  only one thread is used.

- Moved UserExceptionFactory from Ice namespace to IceInternal namespace
  because UserExceptionFactory is no longer an interface for use
  by applications.

- Bi-directional connections are now handled by the client-side thread
  pool instead of the server-side thread pool.

- Fixed a bug in the generated code that caused "at-most-once"
  semantics to be ignored for collocated invocations.

- Removed all Ice dependencies on Xerces. Added a simple C++ wrapper
  around the expat XML parser as IceXML/Parser.h.

- Implemented TwowayOnlyException. That exception is raised if an
  attempt is made to invoke an operation that has a return value,
  out parameters, or an exception specification via a oneway or
  datagram proxy.

- Removed ice_flush() on the proxy base class. Batch requests are
  now flushed by calling Communicator::flushBatchRequests(). This
  flushes all requests that are currently batched in the communicator,
  (for all connections).

- Added back the connection closure timeout, but only for misbehaving
  peers. If a timeout is set, and a peer doesn't react to a close
  connection message, the connection is forcefully closed after the
  timeout. However, it is never forcefully closed if requests are
  still outstanding. Doing so would violate ordering guarantees for
  finished() and deactivate() on servant locators.

- Fixed a bug in the slice2java code generator: if a parameter was
  named "current", illegal code was generated.

- Fixed a bug in the slice2java code generator: tie classes were not
  generated correctly for operations with an "amd" metadata directive.

- On Windows, you can now build IceUtil in such a way that mutexes 
  are used instead of critical sections. See IceUtil/Config.h.

- Fixed a bug where Ice would print a dispatch warning for
  Ice::RequestFailedException even if the Ice.Warn.Dispatch property
  was set to 1.

- Added per-proxy contexts. The change is source-code compatible with
  the previous approach, that is, it is still possible to pass an
  explicit Ice::Context to an operation call as an additional,
  trailing parameter. However, IceProxy::Ice::Object now contains two
  new operations:

  - ice_getContext()

    This returns the context currently associated with a particular
    proxy by value. (By default, the context associated with proxies
    is empty.)

  - ice_newContext(const ::Ice::Context& context)

    This creates a new proxy that is associated with the passed
    context. Thereafter, calls via the new proxy always pass the
    context that was passed to ice_newContext() when that proxy was
    created.

  The net effect of this is that it is now possible to establish the
  context for a proxy once and, thereafter, have that same context
  sent automatically whenever an operation is invoked via the proxy
  (instead of having to pass an explicit context parameter on every
  call).

- Added Ice::Properties::parseIceCommandLineOptions(). This operation
  converts to properties all options that start with one of the
  following prefixes: --Ice, --IceBox, --IcePack, --IcePatch,
  --IceSSL, --IceStorm, --Freeze, and --Glacier.

- Added ice_clone() member function to non-abstract classes.
  ice_clone() polymorphically copies a class instance. The copy is a
  deep copy for all types except for class members; class members are
  copied shallow, that is, if a class contains a class member, the
  original and the clone contain a Ptr that points at the same single
  class instance.

- Improved marshaling performance for built-in types (byte, bool,
  short, int, long, float, double, and string). This is noticeable in
  particular when transmitting sequences of these types, sequences of
  structures containing these types, or large dictionaries containing
  these types.

- Added menu with several options to throughput demo.

- Major Freeze update:

  - Removed support for the XML encoding. Freeze now always uses the
    binary encoding.

  - Removed the lowest Freeze layer. You should now use Berkeley
    DB directly.

  - Replaced the database transformation tool with one that supports
    the binary encoding.

  - For Freeze Maps and Evictors, the underlying Berkeley DB
    environment is now always transactional. New configuration
    variables:

      - Freeze.DbEnv.<envName>.DbHome provides the path to the DB home, 
        and defaults to <envName>.

      - Freeze.DbEnv.<envName>.DbRecoverFatal triggers "fatal recovery" 
        when set to a value other than 0 (defaults to 0).

      - Freeze.DbEnv.<envName>.DbPrivate when set to a value other than 0
        tells Berkeley DB to use process private memory instead of
        shared memory. Defaults to 1. Set it to 0 when you want to run
        db_archive (or another Berkeley DB utility) on a running
        environment.

      - Freeze.DbEnv.<envName>.DbCheckpointPeriod: each Berkeley DB
        environment created by Freeze has an associated thread that
        checkpoints this environment every DbCheckpointPeriod seconds.
        Defaults to 120 seconds.

      - Freeze.DbEnv.<envName>.PeriodicCheckpointMinSize defines the 
        minimum size in kbytes for the periodic checkpoint (see above). 
        This value is passed to Berkeley DB's checkpoint function. Defaults
        to 0 (no minimum).

      - Freeze.DbEnv.<envName>.OldLogsAutoDelete: when set to a value 
        other than 0, old transactional logs no longer in use are deleted
        after each periodic checkpoint. Defaults to 1.

       - Freeze.Trace.Map: trace the Map operations

       - Freeze.Trace.DbEnv: trace the operations on the DbEnv, which
         is shared between Maps and Evictors.

     Such a Freeze-created Berkeley DB environment is created and
     opened when the first Freeze Map or Evictor using it is created,
     and is closed when the last Freeze Map or Evictor using it is
     closed.

  - Freeze Map update:

    Freeze Maps are now opened/created directly using their constructor:

    C++: Map(const Freeze::ConnectionPtr& connection, 
             const std::string& dbName, 
             bool createDb = true);

    Java: public
          Map(Connection connection, 
              String dbName, 
              boolean createDb);

    Connection is a new local interface similar to the DBEnvironment
    local interface (which was removed). However, Connection is not
    thread-safe: access to a given Connection object must be serialized.
    A connection can be used to create a Transaction (similar to the
    old DBTransaction); likewise, a Transaction is not thread-safe. 

    To access concurrently the "same" map, you should create multiple
    connections and associated maps.

    In Java, it is necessary to call close() on the Map if you want to
    close the underlying Berkeley DB database (and indirectly the
    environment) before the Map is finalized.

    As a consequence of using a transactional Berkeley DB environment,
    all Map writes are now transactional:

    - Non-iterator writes use DB_AUTO_COMMIT.

    - Writable iterators (non-const C++ iterators, Java Iterators)
      have an associated transaction that is committed when the
      iterator is closed.

    Concurrent reads and writes to the same underlying Map can
    generate deadlocks, even with a single writer. Berkeley DB detects
    such deadlocks and "kills" one locker (iterator or transaction) to
    resolve it. For non-iterator access, Freeze handles this situation
    and retries transparently. When using iterators, a DeadlockException
    is raised to the application, which is responsible for closing the
    affected iterator(s) or transaction, and retrying.

    Serialized access or concurrent reads never produce deadlocks.

    In C++, the copy constructor and assignment operator of Freeze Map
    iterators duplicate the source iterator. When the source iterator
    is non-const, the duplicate iterator will use the same transaction.
    This transaction is committed only when its last associated iterator
    is closed (i.e., destroyed or assigned end()).

    In both C++ and Java, write operations that are not within a user-
    controlled transaction automatically close all open iterators
    in the target Map. This reduces the likelihood of self-deadlocks.
  
 - Freeze Evictor update:

   Freeze Evictors are now created directly using a static createEvictor
   function:

    C++: Freeze::EvictorPtr
         Freeze::createEvictor(const Ice::CommunicatorPtr& communicator, 
                               const std::string& envName, 
                               const std::string& dbName,
                               const std::vector<IndexPtr> indices = 
                                     std::vector<IndexPtr>(), 
                               bool createDb = true);

    Java (in class Freeze.Util): 
         public static Evictor
         createEvictor(Ice.Communicator communicator, 
                       String envName, 
                       String dbName,
                       Index[] indices, 
                       boolean createDb);

   The persistence strategies have been removed. 

   Ice objects are now saved by a background thread, controlled by
   the following configuration variables.

     - Freeze.Evictor.<envName>.<dbName>.SaveSizeTrigger: as soon as
       SaveSizeTrigger objects have been created, modified or
       destroyed, the background thread wakes up to save them. When set
       to a negative value, there is no size trigger. Defaults to 10.

     - Freeze.Evictor.<envName>.<dbName>.SavePeriod: the saving thread
       wakes up every SavePeriod ms and saves any created, modified or
       destroyed object. When set to 0, there is no periodic wake up.
       Defaults to 1 minute (60,000 ms).

     - Freeze.Evictor.<envName>.<dbName>.MaxTxSize: the saving thread
       saves objects (facets) using transactions. MaxTxSize sets the 
       maximum number of objects saved by a single transaction.
       Defaults to 10 * SaveSizeTrigger; if the provided or default
       value is negative, the actual value is set to 100.
 
    And instead of saving full objects, Freeze now saves on a per facet
    basis -- but still loads complete objects (with all their facets).
    Once a persistent object has been created using the Freeze Evictor,
    it is possible to add or remove persistent facets to this object
    using the following new Evictor operations:
  
      void addFacet(Ice::Identity identity, Ice::FacetPath facet, 
                    Object servant);
      void removeFacet(Ice::Identity identity, Ice::FacetPath facet);
      void removeAllFacets(Ice::Identity identity);

    When saving an object (facet), the background saving thread locks 
    this object. In Java, it locks the object itself; in C++, the object 
    is expected to implement IceUtil::AbstractMutex. Naturally the
    application must use the same synchronization to access the
    persistent state of the object.
 
    The EvictorIterator also changed slightly: the destroy operation
    has been removed. More importantly, identities are now retrieved
    in batch (internally) and the application can request that
    the corresponding servants be loaded. This is achieved with
    the new parameters of Evictor::getIterator:

      EvictorIterator getIterator(int batchSize, bool loadServants);

    You can also define Evictor indices for fast secondary key 
    lookups: see the Freeze/phonebook demo.

 - Freeze now requires Berkeley DB 4.1. It no longer compiles with older
   Berkeley DB releases.

   With Visual C++, you need to use the same project directory
   settings when building Berkeley DB and Ice. In particular, if you
   build Ice with STLPort, you need to build Berkeley DB with the same
   STLPort.

 - Added Freeze hot backup demo.

- Added new C++ AbstractMutex class, and helper templates
  (AbstractMutexI, AbstractMutexReadI, AbstractMutexWriteI) to easily
  implement AbstractMutex using Mutex, RecMutex, Monitor or
  RWRecMutex.

- Fixed a bug in the implementation of StaticMutex on Windows, which
  could result in a crash at exit.

- Added Ice.UDP.RcvSize and Ice.UDP.SndSize properties. These
  properties control the size of the UDP receive and send buffers as
  well as controlling the maximum size of a datagram invocation. If a
  datagram exceeds the configured size, the Ice run time throws a
  DatagramLimitException. (Note that, on the receiving size, detection
  of this condition is dependent on the local UDP implementation --
  some UDP implementations silently drop datagrams that are too large
  to fit into the receive buffer instead of reporting the error or
  delivering a truncated datagram.)

- Added Ice.Warn.Datagrams. This property prints a warning on the
  server side if a DatagramLimitException is thrown.

- Added Ice.MessageSizeMax property. This property controls the
  maximum message size accepted by the Ice protocol in kiloBytes. The
  default value is 1024 (1 MB).

- Fixed a number of incorrect property settings in the config files
  for the demos.

- Added new property: Ice.Trace.Slicing. When set to a value > 0,
  unknown exception and class types that are sliced emit a warning.

- Added destroyOnInterrupt() to the Application class.
  destroyOnInterrupt() is now the default behavior, because
  shutdownOnInterrupt() only shuts down the server side of an
  application, and therefore doesn't work with pure clients.

- ObjectAdapter::removeServantLocator() no longer exists. The life
  cycle of servant locators that are registered with an object adapter
  ends when the adapter is destroyed.

- Changed Ice::ServantLocator::deactivate to be passed the category
  for which a servant locator is being deactivated.

- Added --noindex option to slice2docbook to suppress generation of
  index pages for pdf version of documentation.

- Changed the behavior of Freeze::Map::insert to match the insert
  behavior on associative containers in the C++ standard: if the
  element is already there, it is not updated. Added Freeze::Map::put
  function, to insert or replace an element, like the old insert. This
  corresponds to the behavior of Berkeley DB's DB->put().

- Added a test to the Slice parser to complain if an operation on a
  local interface or class has an exception specification.

- Added a test to the property parsing code to print a warning on
  stderr if a property is not recognized. This prevents silly typos,
  such as "Ice.config=MyFile" (instead of "Ice.Config=MyFile") from
  slipping through undetected.

- Changed the mapping of the Slice byte type: Ice::Byte is now a
  typedef for unsigned char. (Previously, Ice::Byte was a typedef to
  char.) This change guarantees that byte values are always in the
  range 0..255 (instead of either -128..127 or 0..255, depending on
  the CPU architecture). This change also permits function overloading
  for Ice::Byte and char (which can be useful if you use both strings
  and byte sequences).

- Changed the python code for printing output from test clients, so
  that you get each line as it comes.

Changes since version 1.1.0
---------------------------

- Fixed a bug in IceXML that prevented successful extraction of
  strings containing 8-bit characters.

- Added support for a default object factory, similar to the semantics
  of servant locators. Specifically, a factory registered with an
  empty type id is invoked when a type-specific factory cannot be
  found.

- Added Linux/SPARC port from Ferris McCormick.

- Fixed a bug where a daemonized Ice::Application wouldn't shutdown
  properly.

- Added support for user-defined variables in IcePack service and
  server descriptors.

- Fixed server-side bug with batch oneways or batch datagrams.

- Fixed a performance problem in Glacier which would occur when using
  message batching.

- Portability fix in src/IceSSL/OpenSSLPluginI.cpp.

- config/Make.rules now checks that mkshlib is defined.

- src/IceUtil/CtrlCHandler.cpp now handles (ignores) EINTR returned by
  sigwait.

- Added DB_PRIVATE flag to DBEnv->open() on Linux, allowing Ice to use
  the Berkeley DB library included with RedHat 9.

Changes since version 1.0.1
---------------------------

- Added support for Visual Studio .NET 2003 aka VC 7.1

- In IceUtil, all "try" and "timed" functions now return false when
  the resource could not be acquired (i.e., an expected failure). The
  "Try" from "timedTry" functions was removed, and for consistency the
  functions trylock, readlock and writelock were renamed to tryLock,
  readLock and writeLock.

- Update to the library versioning scheme:

  On Windows, only the major and minor version are now used, for
  example: ice11d.dll (11d means 1.1 debug). In 1.0.x, the patch level
  was included in the version string, for example ice101d.dll.

  On Unix, the internal name (soname) is now constructed as
  lib<name>.so.<major version><minor version>, for example
  libIce.so.11 (for Ice 1.1.x). This internal name identifies a
  symbolic link to lib<name>.so.<full version>, for example:
  libIce.so.11 -> libIce.so.1.1.0. In 1.0.x, the internal name was set
  to the actual shared library file name, lib<name>.so.<full version>.

- Ice now implements slicing for exceptions and classes: if a process
  receives an exception or class that is of a more derived type than
  the receiver understands, the exception or class is automatically
  sliced. (Previously, this situation resulted in an exception.)

- Class factories are no longer necessary for non-abstract classes
  (that is, for classes that do not have operations). For non-abstract
  classes, the necessary factories are automatically installed by the
  Ice run time. If you have existing code that implements factories
  for non-abstract classes, you can simply delete that code.  Note
  that for abstract classes (that is, classes with operations), it is
  necessary to install a factory for each abstract class, exactly as
  in version 1.0.x.

- User exception factories and user exception factory managers no
  longer exist. The factories for user exceptions are now
  automatically installed by the Ice run time. If you have existing
  code that implements user exception factories, you can simply delete
  it.

- Fixed a bug in the Slice parser: the semantic check to see whether
  an identifier introduced into a scope has changed meaning was too
  stringent.

- If a client receives a derived exception for which it does not have
  a user exception factory installed, the client receives the
  exception sliced to a known base exception. In 1.0.x, the client
  would have received NoUserExceptionFactoryException, an exception
  that no longer exists in 1.1.x.

- Fixed a bug with connections being closed even though they have
  outstanding batch requests.

- Fixed bug in the WIN32 icepatch client. The removal of orphaned
  files didn't take into account that WIN32 file names are not case
  sensitive.

- New Ice.Nohup property: when its value is >0, shutdownOnInterrupt()
  in Application will ignore SIGHUP on Unix and CTRL_LOGOFF_EVENT on
  Windows.

- Updated Application class: 

  * The default behavior is now shutdownOnInterrupt().

  * Removed the member function defaultInterrupt().
 
- Removed Communicator::signalShutdown(): Ice is not using signal
  handlers anymore, so Communicator::shutdown() can be used all the
  time.

- Added IceUtil::CtrlCHandler: a class that provides portable handling
  of CTRL+C and CTRL+C-like signals,

- Added IceUtil::StaticMutex, for simple, non-recursive, statically
  allocated and initialized mutexes.

- Updated Mutex, RecMutex and RWRecMutex APIs: lock and unlock now
  return void, and trylock returns a bool that indicates whether the
  mutex was acquired or not. Also added new member functions to LockT,
  TryLockT, RLockT, TryLockT, WLockT, TryWLockT: acquire(),
  tryAcquire(), release(), acquired() and more.

- Removed dependency on E2FSPROGS for UUID generation. On Unix, UUIDs
  are now generated directly with /dev/urandom.

- Added support for `env' XML element in IcePack descriptors to allow
  setting environment variables.

- Fixed a bug in the Slice parser: the semantic check to see whether
  an identifier introduced into a scope has changed meaning was too
  stringent.

- Fixed integer parsing bugs in the C++ XML stream class.

- Changed glacier router to send all requests from a separate
  thread. Previously, only requests forwarded as batch would be sent
  from a separate thread.

- Added support for SPARC/Solaris with the Sun C++ 5.3, 5.4 and 5.5
  compilers (32 and 64 bit). See INSTALL.SOLARIS for details.

- Replaced the Freeze::EvictorPersistenceMode enumeration with the
  interface Freeze::PersistenceStrategy.

- Added support for GCC 2.95.3.

- Several incompatible IceStorm changes:

  * Moved the subscribe and unsubscribe operations to the Topic
    interface.

  * Added an object adapter to host publisher objects, and hence a new
    configuration property IceStorm.Publish.Endpoints.

- Added dynamic thread pools, i.e., thread pools that grow and shrink
  based on a calculated load factor. Please see the section about
  thread pools in the manual for further details.

- Structs and sequences which hold other structs or sequences are now
  legal dictionary key types, as long as such nested structs or
  sequences are (recursively) legal.

- The connection timeout is now also used when connections are
  closed. This avoid hanging processes if the peer misbehaves, or if
  asynchronous methods invocations don't return.

- In some cases, communicator destruction could result in a
  NullHandleException. This has been fixed. Now a
  CommunicatorDestroyedException is raised.

- A monitor now holds the mutex lock while signaling a condition
  variable. Otherwise it's possible that the condition variable is
  destroyed before the signaling call returns, resulting in undefined
  behavior. The performance difference is minimal, hardly measurable.

- Further performance improvements with respect to latency.

- Added demo/Ice/throughput, which can be used to measure the transfer
  time of large sequences.

- Fixed a bug in the slice2cpp code generator: if a class was forward
  declared and used as a class member, but the definition of the class
  was not supplied in the same Slice compilation unit, invalid code
  was generated.

- Inlined most operators in IceUtil::Time for performance reasons.

- Added IceUtil::ThreadControl::isAlive(). This function is useful for
  implementing a non-blocking join().

- Added IceUtil::ThreadControl::id() member function.

- The scope of IceUtil::Thread::ThreadId has been changed to
  IceUtil::ThreadId. This is the type returned by both Thread::id()
  and ThreadControl::id().

- Joining with a thread more than once, joining with a detached
  thread, or detaching a detached thread now have undefined
  behavior. (Previously, doing any of these things raised an
  exception.)

- Added timestamps to the default Ice logger. You can enable
  timestamps by setting the `Ice.Logger.Timestamp' property to a value
  larger than zero. By default timestamps are disabled.

- Added several conversion functions to IceUtil::Time: toString,
  toSeconds, toMilliSeconds, toMicroSeconds.

- Fixed a bug in Freeze::DBEnvironment which caused the sync method to
  hang.

- Improved IceBox service deactivation. Instead of successively
  stopping a service and destroying its communicator, services are now
  all stopped first and then their communicators are destroyed.

- Modified the Ice protocol to marshal sizes more efficiently.  Sizes
  less than 255 now require a single byte whereas previously, sizes
  between 127 and 254 required five bytes.

- Modified the Ice protocol to fix a problem with compression. The
  compressed message types have been removed, and a field has been
  added to the message header indicating compression status.

- Added version negotiation to the Ice protocol. This permits future
  protocol extensions to be added without breaking interoperability
  with older deployed clients and servers. Unfortunately, doing this
  broke compatibility with the existing protocol so, when upgrading to
  this version, you must make sure that clients and servers use the
  same version of libIce.so.

- Added a magic number to the Ice protocol. All Ice protocol messages
  have 'I', 'c', 'e', 'P' (encoded as ASCII) in the first four bytes.
  This is useful to allow protocol analyzers to recognize Ice
  messages.

- Changed the encoding of encapsulations. An encapsulation now looks
  like:

	size (4 bytes)
	major version number (1 byte)
	minor version number (1 byte)
	data (n bytes)

  The size includes the count of bytes for the size and versions, so
  the value of size is n + 6.

- Added -v and -e options to stringified UDP endpoints. -v sets the
  protocol version and -e sets the encoding version. (The current
  version for both protocol and encoding is 1.0.)

- Compatibility fixes for GCC 2.96.

- Added `option' and `vm-option' elements to IcePack server
  descriptors. These elements are used to pass command line options to
  server processes.

- Added scandir() and alphasort() for Sun-OS and other Unix systems
  that do not have these BSD calls.

Changes since version 1.0.0
---------------------------

- Added --header-ext and --source-ext command-line options to
  slice2cpp and slice2freeze. These permit setting header and
  source file extensions for C++ other than the default `h' and
  `cpp' file extensions.

- Added the macro ICE_INT64 as a portable wrapper for long long
  constants.

- Added support for Xerces 2.2.0.

- Added support for OpenSSL 0.97a.

- Added OPENSSL_FLAGS to several Makefiles that were missing it.

- Changed signature of IceUtil::Time::milliSeconds() to
  IceUtil::Int64, to avoid overflows.

- Renamed Lock and TryLock templates to LockT and TryLockT, to avoid
  compilation problems with Sun Forte 6.2.

- Fixed a bug with throwing exceptions in AMD calls after invoking
  ice_response().

- Fixed a bug with throwing exceptions in AMI from within
  ice_response().

- For posix threads, PTHREAD_MUTEX_RECURSIVE_NP is now only used if
  __linux__ is defined. Otherwise, PTHREAD_MUTEX_RECURSIVE is used.

- The EPROTO error code is now only used if it is defined (such as
  on Linux).

- Several other changes that make Ice for C++ more portable.

- Updated SSL test certificates. The old ones have expired.
