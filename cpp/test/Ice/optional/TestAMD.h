// **********************************************************************
//
// Copyright (c) 2003-2014 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6b
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __TestAMD_h__
#define __TestAMD_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/GCObject.h>
#include <Ice/AsyncResult.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/SlicedDataF.h>
#include <IceUtil/UndefSysMacros.h>
#include <list>
#include <CustomMap.h>
#include <StringView.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30651
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace IceProxy
{

namespace Test
{

class OneOptional;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::OneOptional>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::OneOptional*);

class MultiOptional;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::MultiOptional>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::MultiOptional*);

class A;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::A>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::A*);

class B;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::B>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::B*);

class C;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::C>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::C*);

class WD;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::WD>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::WD*);

class OptionalWithCustom;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalWithCustom>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::OptionalWithCustom*);

class E;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::E>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::E*);

class F;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::F>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::F*);

class Recursive;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Recursive>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Recursive*);

class Initial;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Test::Initial>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Test::Initial*);

}

}

namespace Test
{

class OneOptional;
bool operator==(const OneOptional&, const OneOptional&);
bool operator<(const OneOptional&, const OneOptional&);
::Ice::Object* upCast(::Test::OneOptional*);
typedef ::IceInternal::Handle< ::Test::OneOptional> OneOptionalPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OneOptional> OneOptionalPrx;
void __patch(OneOptionalPtr&, const ::Ice::ObjectPtr&);

class MultiOptional;
bool operator==(const MultiOptional&, const MultiOptional&);
bool operator<(const MultiOptional&, const MultiOptional&);
::Ice::Object* upCast(::Test::MultiOptional*);
typedef ::IceInternal::Handle< ::Test::MultiOptional> MultiOptionalPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MultiOptional> MultiOptionalPrx;
void __patch(MultiOptionalPtr&, const ::Ice::ObjectPtr&);

class A;
bool operator==(const A&, const A&);
bool operator<(const A&, const A&);
::Ice::Object* upCast(::Test::A*);
typedef ::IceInternal::Handle< ::Test::A> APtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::A> APrx;
void __patch(APtr&, const ::Ice::ObjectPtr&);

class B;
bool operator==(const B&, const B&);
bool operator<(const B&, const B&);
::Ice::Object* upCast(::Test::B*);
typedef ::IceInternal::Handle< ::Test::B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::B> BPrx;
void __patch(BPtr&, const ::Ice::ObjectPtr&);

class C;
bool operator==(const C&, const C&);
bool operator<(const C&, const C&);
::Ice::Object* upCast(::Test::C*);
typedef ::IceInternal::Handle< ::Test::C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::C> CPrx;
void __patch(CPtr&, const ::Ice::ObjectPtr&);

class WD;
bool operator==(const WD&, const WD&);
bool operator<(const WD&, const WD&);
::Ice::Object* upCast(::Test::WD*);
typedef ::IceInternal::Handle< ::Test::WD> WDPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::WD> WDPrx;
void __patch(WDPtr&, const ::Ice::ObjectPtr&);

class OptionalWithCustom;
bool operator==(const OptionalWithCustom&, const OptionalWithCustom&);
bool operator<(const OptionalWithCustom&, const OptionalWithCustom&);
::Ice::Object* upCast(::Test::OptionalWithCustom*);
typedef ::IceInternal::Handle< ::Test::OptionalWithCustom> OptionalWithCustomPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalWithCustom> OptionalWithCustomPrx;
void __patch(OptionalWithCustomPtr&, const ::Ice::ObjectPtr&);

class E;
bool operator==(const E&, const E&);
bool operator<(const E&, const E&);
::Ice::Object* upCast(::Test::E*);
typedef ::IceInternal::Handle< ::Test::E> EPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::E> EPrx;
void __patch(EPtr&, const ::Ice::ObjectPtr&);

class F;
bool operator==(const F&, const F&);
bool operator<(const F&, const F&);
::Ice::Object* upCast(::Test::F*);
typedef ::IceInternal::Handle< ::Test::F> FPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::F> FPrx;
void __patch(FPtr&, const ::Ice::ObjectPtr&);

class Recursive;
bool operator==(const Recursive&, const Recursive&);
bool operator<(const Recursive&, const Recursive&);
::Ice::Object* upCast(::Test::Recursive*);
typedef ::IceInternal::Handle< ::Test::Recursive> RecursivePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Recursive> RecursivePrx;
void __patch(RecursivePtr&, const ::Ice::ObjectPtr&);

class Initial;
bool operator==(const Initial&, const Initial&);
bool operator<(const Initial&, const Initial&);
::Ice::Object* upCast(::Test::Initial*);
typedef ::IceInternal::Handle< ::Test::Initial> InitialPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Initial> InitialPrx;
void __patch(InitialPtr&, const ::Ice::ObjectPtr&);

}

namespace Test
{

enum MyEnum
{
    MyEnumMember
};

struct SmallStruct
{
    ::Ice::Byte m;

    bool operator==(const SmallStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(m != __rhs.m)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SmallStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(m < __rhs.m)
        {
            return true;
        }
        else if(__rhs.m < m)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SmallStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const SmallStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const SmallStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const SmallStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct FixedStruct
{
    ::Ice::Int m;

    bool operator==(const FixedStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(m != __rhs.m)
        {
            return false;
        }
        return true;
    }

    bool operator<(const FixedStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(m < __rhs.m)
        {
            return true;
        }
        else if(__rhs.m < m)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const FixedStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const FixedStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const FixedStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const FixedStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct VarStruct
{
    ::std::string m;

    bool operator==(const VarStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(m != __rhs.m)
        {
            return false;
        }
        return true;
    }

    bool operator<(const VarStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(m < __rhs.m)
        {
            return true;
        }
        else if(__rhs.m < m)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const VarStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const VarStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const VarStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const VarStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

class ClassVarStruct : public IceUtil::Shared
{
public:
    
    ClassVarStruct() {}
    explicit ClassVarStruct(::Ice::Int __ice_a) :
        a(__ice_a)
    {
    }
    

    ::Ice::Int a;

    bool operator==(const ClassVarStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(a != __rhs.a)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ClassVarStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(a < __rhs.a)
        {
            return true;
        }
        else if(__rhs.a < a)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ClassVarStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const ClassVarStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const ClassVarStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const ClassVarStruct& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::IceUtil::Handle< ::Test::ClassVarStruct> ClassVarStructPtr;

typedef ::std::vector< ::Ice::Byte> ByteSeq;

typedef ::std::vector<bool> BoolSeq;

typedef ::std::vector< ::Ice::Short> ShortSeq;

typedef ::std::vector< ::Ice::Int> IntSeq;

typedef ::std::vector< ::Ice::Long> LongSeq;

typedef ::std::vector< ::Ice::Float> FloatSeq;

typedef ::std::vector< ::Ice::Double> DoubleSeq;

typedef ::std::vector< ::std::string> StringSeq;

typedef ::std::vector< ::Test::MyEnum> MyEnumSeq;

typedef ::std::vector< ::Test::SmallStruct> SmallStructSeq;

typedef std::list< ::Test::SmallStruct> SmallStructList;

typedef ::std::vector< ::Test::FixedStruct> FixedStructSeq;

typedef std::list< ::Test::FixedStruct> FixedStructList;

typedef ::std::vector< ::Test::VarStruct> VarStructSeq;

typedef ::std::vector< ::Test::OneOptionalPtr> OneOptionalSeq;

typedef ::std::vector< ::Test::OneOptionalPrx> OneOptionalPrxSeq;

typedef ::std::vector< ::Ice::Byte> Serializable;

typedef ::std::map< ::Ice::Int, ::Ice::Int> IntIntDict;

typedef ::std::map< ::std::string, ::Ice::Int> StringIntDict;

typedef ::std::map< ::Ice::Int, ::Test::MyEnum> IntEnumDict;

typedef ::std::map< ::Ice::Int, ::Test::FixedStruct> IntFixedStructDict;

typedef ::std::map< ::Ice::Int, ::Test::VarStruct> IntVarStructDict;

typedef ::std::map< ::Ice::Int, ::Test::OneOptionalPtr> IntOneOptionalDict;

typedef ::std::map< ::Ice::Int, ::Test::OneOptionalPrx> IntOneOptionalPrxDict;

typedef Test::CustomMap<Ice::Int, std::string> IntStringDict;

class OptionalException : public ::Ice::UserException
{
public:

    OptionalException();
    OptionalException(bool, const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&);
    virtual ~OptionalException() throw();

    virtual ::std::string ice_name() const;
    virtual OptionalException* ice_clone() const;
    virtual void ice_throw() const;

    bool req;
    IceUtil::Optional< ::Ice::Int> a;
    IceUtil::Optional< ::std::string> b;
    IceUtil::Optional< ::Test::OneOptionalPtr> o;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

static OptionalException __OptionalException_init;

class DerivedException : public ::Test::OptionalException
{
public:

    DerivedException();
    DerivedException(bool, const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&);
    virtual ~DerivedException() throw();

    virtual ::std::string ice_name() const;
    virtual DerivedException* ice_clone() const;
    virtual void ice_throw() const;

    IceUtil::Optional< ::std::string> ss;
    IceUtil::Optional< ::Test::OneOptionalPtr> o2;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::OptionalException::__writeImpl;
    using ::Test::OptionalException::__readImpl;
    #endif
};

class RequiredException : public ::Test::OptionalException
{
public:

    RequiredException();
    RequiredException(bool, const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::std::string&, const ::Test::OneOptionalPtr&);
    virtual ~RequiredException() throw();

    virtual ::std::string ice_name() const;
    virtual RequiredException* ice_clone() const;
    virtual void ice_throw() const;

    virtual bool __usesClasses() const;

    ::std::string ss;
    ::Test::OneOptionalPtr o2;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::OptionalException::__writeImpl;
    using ::Test::OptionalException::__readImpl;
    #endif
};

typedef ::std::vector< ::Test::RecursivePtr> RecursiveSeq;

}

namespace Ice
{
template<>
struct StreamableTraits< ::Test::MyEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 0;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::SmallStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::Test::SmallStruct, S>
{
    static void write(S* __os, const ::Test::SmallStruct& v)
    {
        __os->write(v.m);
    }
};

template<class S>
struct StreamReader< ::Test::SmallStruct, S>
{
    static void read(S* __is, ::Test::SmallStruct& v)
    {
        __is->read(v.m);
    }
};

template<>
struct StreamableTraits< ::Test::FixedStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::Test::FixedStruct, S>
{
    static void write(S* __os, const ::Test::FixedStruct& v)
    {
        __os->write(v.m);
    }
};

template<class S>
struct StreamReader< ::Test::FixedStruct, S>
{
    static void read(S* __is, ::Test::FixedStruct& v)
    {
        __is->read(v.m);
    }
};

template<>
struct StreamableTraits< ::Test::VarStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::Test::VarStruct, S>
{
    static void write(S* __os, const ::Test::VarStruct& v)
    {
        __os->write(v.m);
    }
};

template<class S>
struct StreamReader< ::Test::VarStruct, S>
{
    static void read(S* __is, ::Test::VarStruct& v)
    {
        __is->read(v.m);
    }
};

template<>
struct StreamableTraits< ::Test::ClassVarStructPtr>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStructClass;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::Test::ClassVarStructPtr, S>
{
    static void write(S* __os, const ::Test::ClassVarStructPtr& v)
    {
        __os->write(v->a);
    }
};

template<class S>
struct StreamReader< ::Test::ClassVarStructPtr, S>
{
    static void read(S* __is, ::Test::ClassVarStructPtr& v)
    {
        __is->read(v->a);
    }
};

template<>
struct StreamableTraits< ::Test::OptionalException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::DerivedException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::RequiredException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

}

namespace Test
{

class AMD_Initial_shutdown : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_shutdown> AMD_Initial_shutdownPtr;

class AMD_Initial_pingPong : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::ObjectPtr&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_pingPong> AMD_Initial_pingPongPtr;

class AMD_Initial_opOptionalException : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opOptionalException> AMD_Initial_opOptionalExceptionPtr;

class AMD_Initial_opDerivedException : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opDerivedException> AMD_Initial_opDerivedExceptionPtr;

class AMD_Initial_opRequiredException : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opRequiredException> AMD_Initial_opRequiredExceptionPtr;

class AMD_Initial_opByte : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opByte> AMD_Initial_opBytePtr;

class AMD_Initial_opBool : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opBool> AMD_Initial_opBoolPtr;

class AMD_Initial_opShort : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opShort> AMD_Initial_opShortPtr;

class AMD_Initial_opInt : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opInt> AMD_Initial_opIntPtr;

class AMD_Initial_opLong : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opLong> AMD_Initial_opLongPtr;

class AMD_Initial_opFloat : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFloat> AMD_Initial_opFloatPtr;

class AMD_Initial_opDouble : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opDouble> AMD_Initial_opDoublePtr;

class AMD_Initial_opString : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opString> AMD_Initial_opStringPtr;

class AMD_Initial_opCustomString : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional<Util::string_view>&, const IceUtil::Optional<Util::string_view>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opCustomString> AMD_Initial_opCustomStringPtr;

class AMD_Initial_opMyEnum : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Test::MyEnum>&, const IceUtil::Optional< ::Test::MyEnum>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opMyEnum> AMD_Initial_opMyEnumPtr;

class AMD_Initial_opSmallStruct : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opSmallStruct> AMD_Initial_opSmallStructPtr;

class AMD_Initial_opFixedStruct : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Test::FixedStruct>&, const IceUtil::Optional< ::Test::FixedStruct>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFixedStruct> AMD_Initial_opFixedStructPtr;

class AMD_Initial_opVarStruct : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Test::VarStruct>&, const IceUtil::Optional< ::Test::VarStruct>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opVarStruct> AMD_Initial_opVarStructPtr;

class AMD_Initial_opOneOptional : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opOneOptional> AMD_Initial_opOneOptionalPtr;

class AMD_Initial_opOneOptionalProxy : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Test::OneOptionalPrx>&, const IceUtil::Optional< ::Test::OneOptionalPrx>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opOneOptionalProxy> AMD_Initial_opOneOptionalProxyPtr;

class AMD_Initial_opByteSeq : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opByteSeq> AMD_Initial_opByteSeqPtr;

class AMD_Initial_opBoolSeq : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opBoolSeq> AMD_Initial_opBoolSeqPtr;

class AMD_Initial_opShortSeq : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opShortSeq> AMD_Initial_opShortSeqPtr;

class AMD_Initial_opIntSeq : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opIntSeq> AMD_Initial_opIntSeqPtr;

class AMD_Initial_opLongSeq : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opLongSeq> AMD_Initial_opLongSeqPtr;

class AMD_Initial_opFloatSeq : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFloatSeq> AMD_Initial_opFloatSeqPtr;

class AMD_Initial_opDoubleSeq : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opDoubleSeq> AMD_Initial_opDoubleSeqPtr;

class AMD_Initial_opStringSeq : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opStringSeq> AMD_Initial_opStringSeqPtr;

class AMD_Initial_opSmallStructSeq : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opSmallStructSeq> AMD_Initial_opSmallStructSeqPtr;

class AMD_Initial_opSmallStructList : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opSmallStructList> AMD_Initial_opSmallStructListPtr;

class AMD_Initial_opFixedStructSeq : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFixedStructSeq> AMD_Initial_opFixedStructSeqPtr;

class AMD_Initial_opFixedStructList : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFixedStructList> AMD_Initial_opFixedStructListPtr;

class AMD_Initial_opVarStructSeq : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opVarStructSeq> AMD_Initial_opVarStructSeqPtr;

class AMD_Initial_opSerializable : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Test::Serializable>&, const IceUtil::Optional< ::Test::Serializable>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opSerializable> AMD_Initial_opSerializablePtr;

class AMD_Initial_opIntIntDict : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Test::IntIntDict>&, const IceUtil::Optional< ::Test::IntIntDict>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opIntIntDict> AMD_Initial_opIntIntDictPtr;

class AMD_Initial_opStringIntDict : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opStringIntDict> AMD_Initial_opStringIntDictPtr;

class AMD_Initial_opCustomIntStringDict : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opCustomIntStringDict> AMD_Initial_opCustomIntStringDictPtr;

class AMD_Initial_opClassAndUnknownOptional : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opClassAndUnknownOptional> AMD_Initial_opClassAndUnknownOptionalPtr;

class AMD_Initial_sendOptionalClass : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_sendOptionalClass> AMD_Initial_sendOptionalClassPtr;

class AMD_Initial_returnOptionalClass : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const IceUtil::Optional< ::Test::OneOptionalPtr>&) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_returnOptionalClass> AMD_Initial_returnOptionalClassPtr;

class AMD_Initial_supportsRequiredParams : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_supportsRequiredParams> AMD_Initial_supportsRequiredParamsPtr;

class AMD_Initial_supportsJavaSerializable : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_supportsJavaSerializable> AMD_Initial_supportsJavaSerializablePtr;

class AMD_Initial_supportsCsharpSerializable : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_supportsCsharpSerializable> AMD_Initial_supportsCsharpSerializablePtr;

class AMD_Initial_supportsCppStringView : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_supportsCppStringView> AMD_Initial_supportsCppStringViewPtr;

}

namespace IceAsync
{

namespace Test
{

class AMD_Initial_shutdown : public ::Test::AMD_Initial_shutdown, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_shutdown(::IceInternal::Incoming&);

    virtual void ice_response();
};

class AMD_Initial_pingPong : public ::Test::AMD_Initial_pingPong, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_pingPong(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ObjectPtr&);
};

class AMD_Initial_opOptionalException : public ::Test::AMD_Initial_opOptionalException, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opOptionalException(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_Initial_opDerivedException : public ::Test::AMD_Initial_opDerivedException, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opDerivedException(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_Initial_opRequiredException : public ::Test::AMD_Initial_opRequiredException, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opRequiredException(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_Initial_opByte : public ::Test::AMD_Initial_opByte, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opByte(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&);
};

class AMD_Initial_opBool : public ::Test::AMD_Initial_opBool, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opBool(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&);
};

class AMD_Initial_opShort : public ::Test::AMD_Initial_opShort, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opShort(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&);
};

class AMD_Initial_opInt : public ::Test::AMD_Initial_opInt, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opInt(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&);
};

class AMD_Initial_opLong : public ::Test::AMD_Initial_opLong, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opLong(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&);
};

class AMD_Initial_opFloat : public ::Test::AMD_Initial_opFloat, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFloat(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&);
};

class AMD_Initial_opDouble : public ::Test::AMD_Initial_opDouble, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opDouble(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&);
};

class AMD_Initial_opString : public ::Test::AMD_Initial_opString, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opString(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&);
};

class AMD_Initial_opCustomString : public ::Test::AMD_Initial_opCustomString, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opCustomString(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional<Util::string_view>&, const IceUtil::Optional<Util::string_view>&);
};

class AMD_Initial_opMyEnum : public ::Test::AMD_Initial_opMyEnum, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opMyEnum(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::MyEnum>&, const IceUtil::Optional< ::Test::MyEnum>&);
};

class AMD_Initial_opSmallStruct : public ::Test::AMD_Initial_opSmallStruct, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opSmallStruct(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&);
};

class AMD_Initial_opFixedStruct : public ::Test::AMD_Initial_opFixedStruct, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFixedStruct(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::FixedStruct>&, const IceUtil::Optional< ::Test::FixedStruct>&);
};

class AMD_Initial_opVarStruct : public ::Test::AMD_Initial_opVarStruct, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opVarStruct(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::VarStruct>&, const IceUtil::Optional< ::Test::VarStruct>&);
};

class AMD_Initial_opOneOptional : public ::Test::AMD_Initial_opOneOptional, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opOneOptional(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&);
};

class AMD_Initial_opOneOptionalProxy : public ::Test::AMD_Initial_opOneOptionalProxy, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opOneOptionalProxy(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::OneOptionalPrx>&, const IceUtil::Optional< ::Test::OneOptionalPrx>&);
};

class AMD_Initial_opByteSeq : public ::Test::AMD_Initial_opByteSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opByteSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&);
};

class AMD_Initial_opBoolSeq : public ::Test::AMD_Initial_opBoolSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opBoolSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&);
};

class AMD_Initial_opShortSeq : public ::Test::AMD_Initial_opShortSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opShortSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&);
};

class AMD_Initial_opIntSeq : public ::Test::AMD_Initial_opIntSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opIntSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&);
};

class AMD_Initial_opLongSeq : public ::Test::AMD_Initial_opLongSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opLongSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&);
};

class AMD_Initial_opFloatSeq : public ::Test::AMD_Initial_opFloatSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFloatSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&);
};

class AMD_Initial_opDoubleSeq : public ::Test::AMD_Initial_opDoubleSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opDoubleSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&);
};

class AMD_Initial_opStringSeq : public ::Test::AMD_Initial_opStringSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opStringSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&);
};

class AMD_Initial_opSmallStructSeq : public ::Test::AMD_Initial_opSmallStructSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opSmallStructSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&);
};

class AMD_Initial_opSmallStructList : public ::Test::AMD_Initial_opSmallStructList, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opSmallStructList(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&);
};

class AMD_Initial_opFixedStructSeq : public ::Test::AMD_Initial_opFixedStructSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFixedStructSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&);
};

class AMD_Initial_opFixedStructList : public ::Test::AMD_Initial_opFixedStructList, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFixedStructList(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&);
};

class AMD_Initial_opVarStructSeq : public ::Test::AMD_Initial_opVarStructSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opVarStructSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&);
};

class AMD_Initial_opSerializable : public ::Test::AMD_Initial_opSerializable, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opSerializable(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::Serializable>&, const IceUtil::Optional< ::Test::Serializable>&);
};

class AMD_Initial_opIntIntDict : public ::Test::AMD_Initial_opIntIntDict, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opIntIntDict(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::IntIntDict>&, const IceUtil::Optional< ::Test::IntIntDict>&);
};

class AMD_Initial_opStringIntDict : public ::Test::AMD_Initial_opStringIntDict, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opStringIntDict(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&);
};

class AMD_Initial_opCustomIntStringDict : public ::Test::AMD_Initial_opCustomIntStringDict, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opCustomIntStringDict(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&);
};

class AMD_Initial_opClassAndUnknownOptional : public ::Test::AMD_Initial_opClassAndUnknownOptional, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opClassAndUnknownOptional(::IceInternal::Incoming&);

    virtual void ice_response();
};

class AMD_Initial_sendOptionalClass : public ::Test::AMD_Initial_sendOptionalClass, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_sendOptionalClass(::IceInternal::Incoming&);

    virtual void ice_response();
};

class AMD_Initial_returnOptionalClass : public ::Test::AMD_Initial_returnOptionalClass, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_returnOptionalClass(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::OneOptionalPtr>&);
};

class AMD_Initial_supportsRequiredParams : public ::Test::AMD_Initial_supportsRequiredParams, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_supportsRequiredParams(::IceInternal::Incoming&);

    virtual void ice_response(bool);
};

class AMD_Initial_supportsJavaSerializable : public ::Test::AMD_Initial_supportsJavaSerializable, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_supportsJavaSerializable(::IceInternal::Incoming&);

    virtual void ice_response(bool);
};

class AMD_Initial_supportsCsharpSerializable : public ::Test::AMD_Initial_supportsCsharpSerializable, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_supportsCsharpSerializable(::IceInternal::Incoming&);

    virtual void ice_response(bool);
};

class AMD_Initial_supportsCppStringView : public ::Test::AMD_Initial_supportsCppStringView, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_supportsCppStringView(::IceInternal::Incoming&);

    virtual void ice_response(bool);
};

}

}

namespace Test
{

class Callback_Initial_shutdown_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_shutdown_Base> Callback_Initial_shutdownPtr;

class Callback_Initial_pingPong_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_pingPong_Base> Callback_Initial_pingPongPtr;

class Callback_Initial_opOptionalException_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opOptionalException_Base> Callback_Initial_opOptionalExceptionPtr;

class Callback_Initial_opDerivedException_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opDerivedException_Base> Callback_Initial_opDerivedExceptionPtr;

class Callback_Initial_opRequiredException_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opRequiredException_Base> Callback_Initial_opRequiredExceptionPtr;

class Callback_Initial_opByte_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opByte_Base> Callback_Initial_opBytePtr;

class Callback_Initial_opBool_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opBool_Base> Callback_Initial_opBoolPtr;

class Callback_Initial_opShort_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opShort_Base> Callback_Initial_opShortPtr;

class Callback_Initial_opInt_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opInt_Base> Callback_Initial_opIntPtr;

class Callback_Initial_opLong_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opLong_Base> Callback_Initial_opLongPtr;

class Callback_Initial_opFloat_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFloat_Base> Callback_Initial_opFloatPtr;

class Callback_Initial_opDouble_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opDouble_Base> Callback_Initial_opDoublePtr;

class Callback_Initial_opString_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opString_Base> Callback_Initial_opStringPtr;

class Callback_Initial_opCustomString_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opCustomString_Base> Callback_Initial_opCustomStringPtr;

class Callback_Initial_opMyEnum_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opMyEnum_Base> Callback_Initial_opMyEnumPtr;

class Callback_Initial_opSmallStruct_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opSmallStruct_Base> Callback_Initial_opSmallStructPtr;

class Callback_Initial_opFixedStruct_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFixedStruct_Base> Callback_Initial_opFixedStructPtr;

class Callback_Initial_opVarStruct_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opVarStruct_Base> Callback_Initial_opVarStructPtr;

class Callback_Initial_opOneOptional_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opOneOptional_Base> Callback_Initial_opOneOptionalPtr;

class Callback_Initial_opOneOptionalProxy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opOneOptionalProxy_Base> Callback_Initial_opOneOptionalProxyPtr;

class Callback_Initial_opByteSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opByteSeq_Base> Callback_Initial_opByteSeqPtr;

class Callback_Initial_opBoolSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opBoolSeq_Base> Callback_Initial_opBoolSeqPtr;

class Callback_Initial_opShortSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opShortSeq_Base> Callback_Initial_opShortSeqPtr;

class Callback_Initial_opIntSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opIntSeq_Base> Callback_Initial_opIntSeqPtr;

class Callback_Initial_opLongSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opLongSeq_Base> Callback_Initial_opLongSeqPtr;

class Callback_Initial_opFloatSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFloatSeq_Base> Callback_Initial_opFloatSeqPtr;

class Callback_Initial_opDoubleSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opDoubleSeq_Base> Callback_Initial_opDoubleSeqPtr;

class Callback_Initial_opStringSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opStringSeq_Base> Callback_Initial_opStringSeqPtr;

class Callback_Initial_opSmallStructSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opSmallStructSeq_Base> Callback_Initial_opSmallStructSeqPtr;

class Callback_Initial_opSmallStructList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opSmallStructList_Base> Callback_Initial_opSmallStructListPtr;

class Callback_Initial_opFixedStructSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFixedStructSeq_Base> Callback_Initial_opFixedStructSeqPtr;

class Callback_Initial_opFixedStructList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFixedStructList_Base> Callback_Initial_opFixedStructListPtr;

class Callback_Initial_opVarStructSeq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opVarStructSeq_Base> Callback_Initial_opVarStructSeqPtr;

class Callback_Initial_opSerializable_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opSerializable_Base> Callback_Initial_opSerializablePtr;

class Callback_Initial_opIntIntDict_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opIntIntDict_Base> Callback_Initial_opIntIntDictPtr;

class Callback_Initial_opStringIntDict_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opStringIntDict_Base> Callback_Initial_opStringIntDictPtr;

class Callback_Initial_opCustomIntStringDict_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opCustomIntStringDict_Base> Callback_Initial_opCustomIntStringDictPtr;

class Callback_Initial_opClassAndUnknownOptional_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opClassAndUnknownOptional_Base> Callback_Initial_opClassAndUnknownOptionalPtr;

class Callback_Initial_sendOptionalClass_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_sendOptionalClass_Base> Callback_Initial_sendOptionalClassPtr;

class Callback_Initial_returnOptionalClass_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_returnOptionalClass_Base> Callback_Initial_returnOptionalClassPtr;

class Callback_Initial_supportsRequiredParams_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_supportsRequiredParams_Base> Callback_Initial_supportsRequiredParamsPtr;

class Callback_Initial_supportsJavaSerializable_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_supportsJavaSerializable_Base> Callback_Initial_supportsJavaSerializablePtr;

class Callback_Initial_supportsCsharpSerializable_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_supportsCsharpSerializable_Base> Callback_Initial_supportsCsharpSerializablePtr;

class Callback_Initial_supportsCppStringView_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_supportsCppStringView_Base> Callback_Initial_supportsCppStringViewPtr;

}

namespace IceProxy
{

namespace Test
{

class OneOptional : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<OneOptional> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_secure(bool __secure) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_twoway() const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_oneway() const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_batchOneway() const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_datagram() const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_batchDatagram() const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_compress(bool __compress) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_timeout(int __timeout) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OneOptional> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<OneOptional*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class MultiOptional : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_secure(bool __secure) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_twoway() const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_oneway() const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_batchOneway() const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_datagram() const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_batchDatagram() const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_compress(bool __compress) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_timeout(int __timeout) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MultiOptional> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<MultiOptional*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class A : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<A> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_secure(bool __secure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_twoway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_oneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchOneway() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_datagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_batchDatagram() const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_compress(bool __compress) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_timeout(int __timeout) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<A> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<A*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class B : virtual public ::IceProxy::Test::A
{
public:
    
    ::IceInternal::ProxyHandle<B> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_secure(bool __secure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_twoway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_oneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchOneway() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_datagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_batchDatagram() const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_compress(bool __compress) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_timeout(int __timeout) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<B> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<B*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class C : virtual public ::IceProxy::Test::B
{
public:
    
    ::IceInternal::ProxyHandle<C> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_secure(bool __secure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_twoway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_oneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchOneway() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_datagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_batchDatagram() const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_compress(bool __compress) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_timeout(int __timeout) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<C> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<C*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class WD : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<WD> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_secure(bool __secure) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_twoway() const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_oneway() const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_batchOneway() const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_datagram() const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_batchDatagram() const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_compress(bool __compress) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_timeout(int __timeout) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<WD> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<WD*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class OptionalWithCustom : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_secure(bool __secure) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_twoway() const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_oneway() const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_batchOneway() const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_datagram() const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_batchDatagram() const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_compress(bool __compress) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_timeout(int __timeout) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OptionalWithCustom> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<OptionalWithCustom*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class E : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<E> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_secure(bool __secure) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_twoway() const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_oneway() const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_batchOneway() const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_datagram() const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_batchDatagram() const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_compress(bool __compress) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_timeout(int __timeout) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<E> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<E*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class F : virtual public ::IceProxy::Test::E
{
public:
    
    ::IceInternal::ProxyHandle<F> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_secure(bool __secure) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_twoway() const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_oneway() const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_batchOneway() const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_datagram() const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_batchDatagram() const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_compress(bool __compress) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_timeout(int __timeout) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<F> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<F*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Recursive : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Recursive> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_secure(bool __secure) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_twoway() const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_oneway() const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_batchOneway() const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_datagram() const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_batchDatagram() const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_compress(bool __compress) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Recursive> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Recursive*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Initial : virtual public ::IceProxy::Ice::Object
{
public:

    void shutdown()
    {
        shutdown(0);
    }
    void shutdown(const ::Ice::Context& __ctx)
    {
        shutdown(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_shutdown(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_shutdown(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_shutdown(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_shutdown(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_shutdown()
    {
        return begin_shutdown(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx)
    {
        return begin_shutdown(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_Initial_shutdownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_shutdownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(&__ctx, __del, __cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr&);
    
private:

    void shutdown(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::ObjectPtr pingPong(const ::Ice::ObjectPtr& o)
    {
        return pingPong(o, 0);
    }
    ::Ice::ObjectPtr pingPong(const ::Ice::ObjectPtr& o, const ::Ice::Context& __ctx)
    {
        return pingPong(o, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_pingPong(const ::Ice::ObjectPtr& o, const ::IceInternal::Function<void (const ::Ice::ObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_pingPong(o, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_pingPong(const ::Ice::ObjectPtr& o, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_pingPong(o, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_pingPong(const ::Ice::ObjectPtr& o, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_pingPong(o, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_pingPong(const ::Ice::ObjectPtr& o, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_pingPong(o, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_pingPong(const ::Ice::ObjectPtr& o, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_pingPong(const ::Ice::ObjectPtr& o)
    {
        return begin_pingPong(o, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pingPong(const ::Ice::ObjectPtr& o, const ::Ice::Context& __ctx)
    {
        return begin_pingPong(o, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pingPong(const ::Ice::ObjectPtr& o, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pingPong(o, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_pingPong(const ::Ice::ObjectPtr& o, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pingPong(o, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_pingPong(const ::Ice::ObjectPtr& o, const ::Test::Callback_Initial_pingPongPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pingPong(o, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_pingPong(const ::Ice::ObjectPtr& o, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_pingPongPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pingPong(o, &__ctx, __del, __cookie);
    }

    ::Ice::ObjectPtr end_pingPong(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ObjectPtr pingPong(const ::Ice::ObjectPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_pingPong(const ::Ice::ObjectPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o)
    {
        opOptionalException(a, b, o, 0);
    }
    void opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx)
    {
        opOptionalException(a, b, o, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opOptionalException(a, b, o, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opOptionalException(a, b, o, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opOptionalException(a, b, o, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opOptionalException(a, b, o, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o)
    {
        return begin_opOptionalException(a, b, o, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx)
    {
        return begin_opOptionalException(a, b, o, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOptionalException(a, b, o, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOptionalException(a, b, o, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Test::Callback_Initial_opOptionalExceptionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOptionalException(a, b, o, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opOptionalExceptionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOptionalException(a, b, o, &__ctx, __del, __cookie);
    }

    void end_opOptionalException(const ::Ice::AsyncResultPtr&);
    
private:

    void opOptionalException(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o)
    {
        opDerivedException(a, b, o, 0);
    }
    void opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx)
    {
        opDerivedException(a, b, o, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opDerivedException(a, b, o, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opDerivedException(a, b, o, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opDerivedException(a, b, o, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opDerivedException(a, b, o, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o)
    {
        return begin_opDerivedException(a, b, o, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx)
    {
        return begin_opDerivedException(a, b, o, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDerivedException(a, b, o, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDerivedException(a, b, o, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Test::Callback_Initial_opDerivedExceptionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDerivedException(a, b, o, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opDerivedExceptionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDerivedException(a, b, o, &__ctx, __del, __cookie);
    }

    void end_opDerivedException(const ::Ice::AsyncResultPtr&);
    
private:

    void opDerivedException(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o)
    {
        opRequiredException(a, b, o, 0);
    }
    void opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx)
    {
        opRequiredException(a, b, o, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opRequiredException(a, b, o, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opRequiredException(a, b, o, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opRequiredException(a, b, o, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opRequiredException(a, b, o, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o)
    {
        return begin_opRequiredException(a, b, o, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx)
    {
        return begin_opRequiredException(a, b, o, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opRequiredException(a, b, o, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opRequiredException(a, b, o, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Test::Callback_Initial_opRequiredExceptionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opRequiredException(a, b, o, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opRequiredExceptionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opRequiredException(a, b, o, &__ctx, __del, __cookie);
    }

    void end_opRequiredException(const ::Ice::AsyncResultPtr&);
    
private:

    void opRequiredException(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Ice::Byte> opByte(const IceUtil::Optional< ::Ice::Byte>& p1, IceUtil::Optional< ::Ice::Byte>& p3)
    {
        return opByte(p1, p3, 0);
    }
    IceUtil::Optional< ::Ice::Byte> opByte(const IceUtil::Optional< ::Ice::Byte>& p1, IceUtil::Optional< ::Ice::Byte>& p3, const ::Ice::Context& __ctx)
    {
        return opByte(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByte(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByte(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByte(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByte(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1)
    {
        return begin_opByte(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opByte(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByte(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByte(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Test::Callback_Initial_opBytePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByte(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opBytePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByte(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Ice::Byte> end_opByte(IceUtil::Optional< ::Ice::Byte>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Ice::Byte> opByte(const IceUtil::Optional< ::Ice::Byte>&, IceUtil::Optional< ::Ice::Byte>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opByte(const IceUtil::Optional< ::Ice::Byte>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional<bool> opBool(const IceUtil::Optional<bool>& p1, IceUtil::Optional<bool>& p3)
    {
        return opBool(p1, p3, 0);
    }
    IceUtil::Optional<bool> opBool(const IceUtil::Optional<bool>& p1, IceUtil::Optional<bool>& p3, const ::Ice::Context& __ctx)
    {
        return opBool(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBool(const IceUtil::Optional<bool>& p1, const ::IceInternal::Function<void (const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBool(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBool(const IceUtil::Optional<bool>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBool(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBool(const IceUtil::Optional<bool>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBool(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBool(const IceUtil::Optional<bool>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBool(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBool(const IceUtil::Optional<bool>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBool(const IceUtil::Optional<bool>& p1)
    {
        return begin_opBool(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBool(const IceUtil::Optional<bool>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opBool(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBool(const IceUtil::Optional<bool>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBool(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBool(const IceUtil::Optional<bool>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBool(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBool(const IceUtil::Optional<bool>& p1, const ::Test::Callback_Initial_opBoolPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBool(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBool(const IceUtil::Optional<bool>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opBoolPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBool(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional<bool> end_opBool(IceUtil::Optional<bool>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional<bool> opBool(const IceUtil::Optional<bool>&, IceUtil::Optional<bool>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBool(const IceUtil::Optional<bool>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Ice::Short> opShort(const IceUtil::Optional< ::Ice::Short>& p1, IceUtil::Optional< ::Ice::Short>& p3)
    {
        return opShort(p1, p3, 0);
    }
    IceUtil::Optional< ::Ice::Short> opShort(const IceUtil::Optional< ::Ice::Short>& p1, IceUtil::Optional< ::Ice::Short>& p3, const ::Ice::Context& __ctx)
    {
        return opShort(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShort(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShort(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShort(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShort(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1)
    {
        return begin_opShort(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opShort(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShort(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShort(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::Test::Callback_Initial_opShortPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShort(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opShortPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShort(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Ice::Short> end_opShort(IceUtil::Optional< ::Ice::Short>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Ice::Short> opShort(const IceUtil::Optional< ::Ice::Short>&, IceUtil::Optional< ::Ice::Short>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opShort(const IceUtil::Optional< ::Ice::Short>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Ice::Int> opInt(const IceUtil::Optional< ::Ice::Int>& p1, IceUtil::Optional< ::Ice::Int>& p3)
    {
        return opInt(p1, p3, 0);
    }
    IceUtil::Optional< ::Ice::Int> opInt(const IceUtil::Optional< ::Ice::Int>& p1, IceUtil::Optional< ::Ice::Int>& p3, const ::Ice::Context& __ctx)
    {
        return opInt(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opInt(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opInt(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opInt(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opInt(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1)
    {
        return begin_opInt(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opInt(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opInt(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opInt(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::Test::Callback_Initial_opIntPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opInt(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opIntPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opInt(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Ice::Int> end_opInt(IceUtil::Optional< ::Ice::Int>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Ice::Int> opInt(const IceUtil::Optional< ::Ice::Int>&, IceUtil::Optional< ::Ice::Int>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opInt(const IceUtil::Optional< ::Ice::Int>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Ice::Long> opLong(const IceUtil::Optional< ::Ice::Long>& p1, IceUtil::Optional< ::Ice::Long>& p3)
    {
        return opLong(p1, p3, 0);
    }
    IceUtil::Optional< ::Ice::Long> opLong(const IceUtil::Optional< ::Ice::Long>& p1, IceUtil::Optional< ::Ice::Long>& p3, const ::Ice::Context& __ctx)
    {
        return opLong(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opLong(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opLong(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opLong(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opLong(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1)
    {
        return begin_opLong(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opLong(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opLong(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opLong(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::Test::Callback_Initial_opLongPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opLong(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opLongPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opLong(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Ice::Long> end_opLong(IceUtil::Optional< ::Ice::Long>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Ice::Long> opLong(const IceUtil::Optional< ::Ice::Long>&, IceUtil::Optional< ::Ice::Long>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opLong(const IceUtil::Optional< ::Ice::Long>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Ice::Float> opFloat(const IceUtil::Optional< ::Ice::Float>& p1, IceUtil::Optional< ::Ice::Float>& p3)
    {
        return opFloat(p1, p3, 0);
    }
    IceUtil::Optional< ::Ice::Float> opFloat(const IceUtil::Optional< ::Ice::Float>& p1, IceUtil::Optional< ::Ice::Float>& p3, const ::Ice::Context& __ctx)
    {
        return opFloat(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFloat(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFloat(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFloat(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFloat(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1)
    {
        return begin_opFloat(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opFloat(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloat(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloat(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::Test::Callback_Initial_opFloatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloat(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opFloatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloat(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Ice::Float> end_opFloat(IceUtil::Optional< ::Ice::Float>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Ice::Float> opFloat(const IceUtil::Optional< ::Ice::Float>&, IceUtil::Optional< ::Ice::Float>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opFloat(const IceUtil::Optional< ::Ice::Float>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Ice::Double> opDouble(const IceUtil::Optional< ::Ice::Double>& p1, IceUtil::Optional< ::Ice::Double>& p3)
    {
        return opDouble(p1, p3, 0);
    }
    IceUtil::Optional< ::Ice::Double> opDouble(const IceUtil::Optional< ::Ice::Double>& p1, IceUtil::Optional< ::Ice::Double>& p3, const ::Ice::Context& __ctx)
    {
        return opDouble(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opDouble(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opDouble(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opDouble(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opDouble(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1)
    {
        return begin_opDouble(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opDouble(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDouble(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDouble(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::Test::Callback_Initial_opDoublePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDouble(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opDoublePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDouble(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Ice::Double> end_opDouble(IceUtil::Optional< ::Ice::Double>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Ice::Double> opDouble(const IceUtil::Optional< ::Ice::Double>&, IceUtil::Optional< ::Ice::Double>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opDouble(const IceUtil::Optional< ::Ice::Double>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::std::string> opString(const IceUtil::Optional< ::std::string>& p1, IceUtil::Optional< ::std::string>& p3)
    {
        return opString(p1, p3, 0);
    }
    IceUtil::Optional< ::std::string> opString(const IceUtil::Optional< ::std::string>& p1, IceUtil::Optional< ::std::string>& p3, const ::Ice::Context& __ctx)
    {
        return opString(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opString(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opString(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opString(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opString(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opString(const IceUtil::Optional< ::std::string>& p1)
    {
        return begin_opString(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opString(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opString(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opString(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::Test::Callback_Initial_opStringPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opString(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opStringPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opString(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::std::string> end_opString(IceUtil::Optional< ::std::string>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::std::string> opString(const IceUtil::Optional< ::std::string>&, IceUtil::Optional< ::std::string>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opString(const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::std::string> opCustomString(const IceUtil::Optional<Util::string_view>& p1, IceUtil::Optional< ::std::string>& p3)
    {
        return opCustomString(p1, p3, 0);
    }
    IceUtil::Optional< ::std::string> opCustomString(const IceUtil::Optional<Util::string_view>& p1, IceUtil::Optional< ::std::string>& p3, const ::Ice::Context& __ctx)
    {
        return opCustomString(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opCustomString(const IceUtil::Optional<Util::string_view>& p1, const ::IceInternal::Function<void (const IceUtil::Optional<Util::string_view>&, const IceUtil::Optional<Util::string_view>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opCustomString(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opCustomString(const IceUtil::Optional<Util::string_view>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opCustomString(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opCustomString(const IceUtil::Optional<Util::string_view>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional<Util::string_view>&, const IceUtil::Optional<Util::string_view>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opCustomString(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opCustomString(const IceUtil::Optional<Util::string_view>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opCustomString(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opCustomString(const IceUtil::Optional<Util::string_view>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional<Util::string_view>&, const IceUtil::Optional<Util::string_view>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opCustomString(const IceUtil::Optional<Util::string_view>& p1)
    {
        return begin_opCustomString(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCustomString(const IceUtil::Optional<Util::string_view>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opCustomString(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCustomString(const IceUtil::Optional<Util::string_view>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCustomString(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomString(const IceUtil::Optional<Util::string_view>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCustomString(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomString(const IceUtil::Optional<Util::string_view>& p1, const ::Test::Callback_Initial_opCustomStringPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCustomString(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomString(const IceUtil::Optional<Util::string_view>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opCustomStringPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCustomString(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::std::string> end_opCustomString(IceUtil::Optional< ::std::string>& p3, const ::Ice::AsyncResultPtr&);

     void ___end_opCustomString(IceUtil::Optional<Util::string_view>& p3, IceUtil::Optional<Util::string_view>& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::std::string> opCustomString(const IceUtil::Optional<Util::string_view>&, IceUtil::Optional< ::std::string>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opCustomString(const IceUtil::Optional<Util::string_view>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::MyEnum> opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, IceUtil::Optional< ::Test::MyEnum>& p3)
    {
        return opMyEnum(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::MyEnum> opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, IceUtil::Optional< ::Test::MyEnum>& p3, const ::Ice::Context& __ctx)
    {
        return opMyEnum(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::MyEnum>&, const IceUtil::Optional< ::Test::MyEnum>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opMyEnum(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opMyEnum(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::MyEnum>&, const IceUtil::Optional< ::Test::MyEnum>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opMyEnum(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opMyEnum(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::MyEnum>&, const IceUtil::Optional< ::Test::MyEnum>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1)
    {
        return begin_opMyEnum(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opMyEnum(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyEnum(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyEnum(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Test::Callback_Initial_opMyEnumPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyEnum(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opMyEnumPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opMyEnum(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::MyEnum> end_opMyEnum(IceUtil::Optional< ::Test::MyEnum>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::MyEnum> opMyEnum(const IceUtil::Optional< ::Test::MyEnum>&, IceUtil::Optional< ::Test::MyEnum>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::SmallStruct> opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, IceUtil::Optional< ::Test::SmallStruct>& p3)
    {
        return opSmallStruct(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::SmallStruct> opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, IceUtil::Optional< ::Test::SmallStruct>& p3, const ::Ice::Context& __ctx)
    {
        return opSmallStruct(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opSmallStruct(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opSmallStruct(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opSmallStruct(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opSmallStruct(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1)
    {
        return begin_opSmallStruct(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opSmallStruct(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSmallStruct(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSmallStruct(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Test::Callback_Initial_opSmallStructPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSmallStruct(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opSmallStructPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSmallStruct(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::SmallStruct> end_opSmallStruct(IceUtil::Optional< ::Test::SmallStruct>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::SmallStruct> opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>&, IceUtil::Optional< ::Test::SmallStruct>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::FixedStruct> opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, IceUtil::Optional< ::Test::FixedStruct>& p3)
    {
        return opFixedStruct(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::FixedStruct> opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, IceUtil::Optional< ::Test::FixedStruct>& p3, const ::Ice::Context& __ctx)
    {
        return opFixedStruct(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::FixedStruct>&, const IceUtil::Optional< ::Test::FixedStruct>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFixedStruct(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFixedStruct(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::FixedStruct>&, const IceUtil::Optional< ::Test::FixedStruct>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFixedStruct(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFixedStruct(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::FixedStruct>&, const IceUtil::Optional< ::Test::FixedStruct>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1)
    {
        return begin_opFixedStruct(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opFixedStruct(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedStruct(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedStruct(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Test::Callback_Initial_opFixedStructPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedStruct(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opFixedStructPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedStruct(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::FixedStruct> end_opFixedStruct(IceUtil::Optional< ::Test::FixedStruct>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::FixedStruct> opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>&, IceUtil::Optional< ::Test::FixedStruct>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::VarStruct> opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, IceUtil::Optional< ::Test::VarStruct>& p3)
    {
        return opVarStruct(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::VarStruct> opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, IceUtil::Optional< ::Test::VarStruct>& p3, const ::Ice::Context& __ctx)
    {
        return opVarStruct(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::VarStruct>&, const IceUtil::Optional< ::Test::VarStruct>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVarStruct(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVarStruct(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::VarStruct>&, const IceUtil::Optional< ::Test::VarStruct>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVarStruct(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVarStruct(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::VarStruct>&, const IceUtil::Optional< ::Test::VarStruct>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1)
    {
        return begin_opVarStruct(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opVarStruct(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVarStruct(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVarStruct(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Test::Callback_Initial_opVarStructPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVarStruct(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opVarStructPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVarStruct(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::VarStruct> end_opVarStruct(IceUtil::Optional< ::Test::VarStruct>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::VarStruct> opVarStruct(const IceUtil::Optional< ::Test::VarStruct>&, IceUtil::Optional< ::Test::VarStruct>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::OneOptionalPtr> opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, IceUtil::Optional< ::Test::OneOptionalPtr>& p3)
    {
        return opOneOptional(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::OneOptionalPtr> opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, IceUtil::Optional< ::Test::OneOptionalPtr>& p3, const ::Ice::Context& __ctx)
    {
        return opOneOptional(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opOneOptional(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opOneOptional(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opOneOptional(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opOneOptional(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1)
    {
        return begin_opOneOptional(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opOneOptional(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOneOptional(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOneOptional(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Test::Callback_Initial_opOneOptionalPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOneOptional(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opOneOptionalPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOneOptional(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::OneOptionalPtr> end_opOneOptional(IceUtil::Optional< ::Test::OneOptionalPtr>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::OneOptionalPtr> opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>&, IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::OneOptionalPrx> opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, IceUtil::Optional< ::Test::OneOptionalPrx>& p3)
    {
        return opOneOptionalProxy(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::OneOptionalPrx> opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, IceUtil::Optional< ::Test::OneOptionalPrx>& p3, const ::Ice::Context& __ctx)
    {
        return opOneOptionalProxy(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::OneOptionalPrx>&, const IceUtil::Optional< ::Test::OneOptionalPrx>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opOneOptionalProxy(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opOneOptionalProxy(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::OneOptionalPrx>&, const IceUtil::Optional< ::Test::OneOptionalPrx>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opOneOptionalProxy(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opOneOptionalProxy(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::OneOptionalPrx>&, const IceUtil::Optional< ::Test::OneOptionalPrx>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1)
    {
        return begin_opOneOptionalProxy(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opOneOptionalProxy(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOneOptionalProxy(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOneOptionalProxy(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Test::Callback_Initial_opOneOptionalProxyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOneOptionalProxy(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opOneOptionalProxyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opOneOptionalProxy(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::OneOptionalPrx> end_opOneOptionalProxy(IceUtil::Optional< ::Test::OneOptionalPrx>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::OneOptionalPrx> opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>&, IceUtil::Optional< ::Test::OneOptionalPrx>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::ByteSeq> opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p1, IceUtil::Optional< ::Test::ByteSeq>& p3)
    {
        return opByteSeq(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::ByteSeq> opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p1, IceUtil::Optional< ::Test::ByteSeq>& p3, const ::Ice::Context& __ctx)
    {
        return opByteSeq(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteSeq(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteSeq(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opByteSeq(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opByteSeq(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p1)
    {
        return begin_opByteSeq(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opByteSeq(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSeq(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p1, const ::Test::Callback_Initial_opByteSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opByteSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opByteSeq(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::ByteSeq> end_opByteSeq(IceUtil::Optional< ::Test::ByteSeq>& p3, const ::Ice::AsyncResultPtr&);

     void ___end_opByteSeq(IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& p3, IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::ByteSeq> opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, IceUtil::Optional< ::Test::ByteSeq>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opByteSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::BoolSeq> opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >& p1, IceUtil::Optional< ::Test::BoolSeq>& p3)
    {
        return opBoolSeq(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::BoolSeq> opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >& p1, IceUtil::Optional< ::Test::BoolSeq>& p3, const ::Ice::Context& __ctx)
    {
        return opBoolSeq(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolSeq(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolSeq(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opBoolSeq(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opBoolSeq(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >& p1)
    {
        return begin_opBoolSeq(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opBoolSeq(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolSeq(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >& p1, const ::Test::Callback_Initial_opBoolSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opBoolSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opBoolSeq(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::BoolSeq> end_opBoolSeq(IceUtil::Optional< ::Test::BoolSeq>& p3, const ::Ice::AsyncResultPtr&);

     void ___end_opBoolSeq(IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > >& p3, IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::BoolSeq> opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, IceUtil::Optional< ::Test::BoolSeq>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opBoolSeq(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::ShortSeq> opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >& p1, IceUtil::Optional< ::Test::ShortSeq>& p3)
    {
        return opShortSeq(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::ShortSeq> opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >& p1, IceUtil::Optional< ::Test::ShortSeq>& p3, const ::Ice::Context& __ctx)
    {
        return opShortSeq(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShortSeq(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShortSeq(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opShortSeq(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opShortSeq(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >& p1)
    {
        return begin_opShortSeq(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opShortSeq(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortSeq(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >& p1, const ::Test::Callback_Initial_opShortSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opShortSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opShortSeq(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::ShortSeq> end_opShortSeq(IceUtil::Optional< ::Test::ShortSeq>& p3, const ::Ice::AsyncResultPtr&);

     void ___end_opShortSeq(IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Short>, ::std::pair<const  ::Ice::Short*, const  ::Ice::Short*> > >& p3, IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Short>, ::std::pair<const  ::Ice::Short*, const  ::Ice::Short*> > >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::ShortSeq> opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, IceUtil::Optional< ::Test::ShortSeq>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opShortSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::IntSeq> opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >& p1, IceUtil::Optional< ::Test::IntSeq>& p3)
    {
        return opIntSeq(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::IntSeq> opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >& p1, IceUtil::Optional< ::Test::IntSeq>& p3, const ::Ice::Context& __ctx)
    {
        return opIntSeq(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opIntSeq(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opIntSeq(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opIntSeq(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opIntSeq(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >& p1)
    {
        return begin_opIntSeq(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opIntSeq(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntSeq(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >& p1, const ::Test::Callback_Initial_opIntSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opIntSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntSeq(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::IntSeq> end_opIntSeq(IceUtil::Optional< ::Test::IntSeq>& p3, const ::Ice::AsyncResultPtr&);

     void ___end_opIntSeq(IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Int>, ::std::pair<const  ::Ice::Int*, const  ::Ice::Int*> > >& p3, IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Int>, ::std::pair<const  ::Ice::Int*, const  ::Ice::Int*> > >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::IntSeq> opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, IceUtil::Optional< ::Test::IntSeq>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opIntSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::LongSeq> opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >& p1, IceUtil::Optional< ::Test::LongSeq>& p3)
    {
        return opLongSeq(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::LongSeq> opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >& p1, IceUtil::Optional< ::Test::LongSeq>& p3, const ::Ice::Context& __ctx)
    {
        return opLongSeq(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opLongSeq(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opLongSeq(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opLongSeq(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opLongSeq(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >& p1)
    {
        return begin_opLongSeq(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opLongSeq(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opLongSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opLongSeq(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >& p1, const ::Test::Callback_Initial_opLongSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opLongSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opLongSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opLongSeq(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::LongSeq> end_opLongSeq(IceUtil::Optional< ::Test::LongSeq>& p3, const ::Ice::AsyncResultPtr&);

     void ___end_opLongSeq(IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Long>, ::std::pair<const  ::Ice::Long*, const  ::Ice::Long*> > >& p3, IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Long>, ::std::pair<const  ::Ice::Long*, const  ::Ice::Long*> > >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::LongSeq> opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, IceUtil::Optional< ::Test::LongSeq>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opLongSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::FloatSeq> opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >& p1, IceUtil::Optional< ::Test::FloatSeq>& p3)
    {
        return opFloatSeq(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::FloatSeq> opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >& p1, IceUtil::Optional< ::Test::FloatSeq>& p3, const ::Ice::Context& __ctx)
    {
        return opFloatSeq(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFloatSeq(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFloatSeq(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFloatSeq(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFloatSeq(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >& p1)
    {
        return begin_opFloatSeq(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opFloatSeq(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatSeq(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >& p1, const ::Test::Callback_Initial_opFloatSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opFloatSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFloatSeq(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::FloatSeq> end_opFloatSeq(IceUtil::Optional< ::Test::FloatSeq>& p3, const ::Ice::AsyncResultPtr&);

     void ___end_opFloatSeq(IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Float>, ::std::pair<const  ::Ice::Float*, const  ::Ice::Float*> > >& p3, IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Float>, ::std::pair<const  ::Ice::Float*, const  ::Ice::Float*> > >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::FloatSeq> opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, IceUtil::Optional< ::Test::FloatSeq>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opFloatSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::DoubleSeq> opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >& p1, IceUtil::Optional< ::Test::DoubleSeq>& p3)
    {
        return opDoubleSeq(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::DoubleSeq> opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >& p1, IceUtil::Optional< ::Test::DoubleSeq>& p3, const ::Ice::Context& __ctx)
    {
        return opDoubleSeq(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opDoubleSeq(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opDoubleSeq(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opDoubleSeq(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opDoubleSeq(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >& p1)
    {
        return begin_opDoubleSeq(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opDoubleSeq(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDoubleSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDoubleSeq(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >& p1, const ::Test::Callback_Initial_opDoubleSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDoubleSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opDoubleSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opDoubleSeq(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::DoubleSeq> end_opDoubleSeq(IceUtil::Optional< ::Test::DoubleSeq>& p3, const ::Ice::AsyncResultPtr&);

     void ___end_opDoubleSeq(IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > >& p3, IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::DoubleSeq> opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, IceUtil::Optional< ::Test::DoubleSeq>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opDoubleSeq(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::StringSeq> opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >& p1, IceUtil::Optional< ::Test::StringSeq>& p3)
    {
        return opStringSeq(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::StringSeq> opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >& p1, IceUtil::Optional< ::Test::StringSeq>& p3, const ::Ice::Context& __ctx)
    {
        return opStringSeq(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringSeq(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringSeq(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringSeq(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringSeq(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >& p1)
    {
        return begin_opStringSeq(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opStringSeq(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSeq(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >& p1, const ::Test::Callback_Initial_opStringSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opStringSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringSeq(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::StringSeq> end_opStringSeq(IceUtil::Optional< ::Test::StringSeq>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::StringSeq> opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, IceUtil::Optional< ::Test::StringSeq>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opStringSeq(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::SmallStructSeq> opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, IceUtil::Optional< ::Test::SmallStructSeq>& p3)
    {
        return opSmallStructSeq(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::SmallStructSeq> opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, IceUtil::Optional< ::Test::SmallStructSeq>& p3, const ::Ice::Context& __ctx)
    {
        return opSmallStructSeq(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opSmallStructSeq(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opSmallStructSeq(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opSmallStructSeq(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opSmallStructSeq(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1)
    {
        return begin_opSmallStructSeq(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opSmallStructSeq(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSmallStructSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSmallStructSeq(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Test::Callback_Initial_opSmallStructSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSmallStructSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opSmallStructSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSmallStructSeq(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::SmallStructSeq> end_opSmallStructSeq(IceUtil::Optional< ::Test::SmallStructSeq>& p3, const ::Ice::AsyncResultPtr&);

     void ___end_opSmallStructSeq(IceUtil::Optional< ::std::vector< ::Test::SmallStruct> >& p3, IceUtil::Optional< ::std::vector< ::Test::SmallStruct> >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::SmallStructSeq> opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, IceUtil::Optional< ::Test::SmallStructSeq>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opSmallStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::SmallStructList> opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, IceUtil::Optional< ::Test::SmallStructList>& p3)
    {
        return opSmallStructList(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::SmallStructList> opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, IceUtil::Optional< ::Test::SmallStructList>& p3, const ::Ice::Context& __ctx)
    {
        return opSmallStructList(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opSmallStructList(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opSmallStructList(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opSmallStructList(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opSmallStructList(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1)
    {
        return begin_opSmallStructList(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opSmallStructList(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSmallStructList(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSmallStructList(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Test::Callback_Initial_opSmallStructListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSmallStructList(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opSmallStructListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSmallStructList(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::SmallStructList> end_opSmallStructList(IceUtil::Optional< ::Test::SmallStructList>& p3, const ::Ice::AsyncResultPtr&);

     void ___end_opSmallStructList(IceUtil::Optional< ::std::vector< ::Test::SmallStruct> >& p3, IceUtil::Optional< ::std::vector< ::Test::SmallStruct> >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::SmallStructList> opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, IceUtil::Optional< ::Test::SmallStructList>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opSmallStructList(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::FixedStructSeq> opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, IceUtil::Optional< ::Test::FixedStructSeq>& p3)
    {
        return opFixedStructSeq(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::FixedStructSeq> opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, IceUtil::Optional< ::Test::FixedStructSeq>& p3, const ::Ice::Context& __ctx)
    {
        return opFixedStructSeq(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFixedStructSeq(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFixedStructSeq(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFixedStructSeq(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFixedStructSeq(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1)
    {
        return begin_opFixedStructSeq(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opFixedStructSeq(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedStructSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedStructSeq(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Test::Callback_Initial_opFixedStructSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedStructSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opFixedStructSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedStructSeq(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::FixedStructSeq> end_opFixedStructSeq(IceUtil::Optional< ::Test::FixedStructSeq>& p3, const ::Ice::AsyncResultPtr&);

     void ___end_opFixedStructSeq(IceUtil::Optional< ::std::vector< ::Test::FixedStruct> >& p3, IceUtil::Optional< ::std::vector< ::Test::FixedStruct> >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::FixedStructSeq> opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, IceUtil::Optional< ::Test::FixedStructSeq>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opFixedStructSeq(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::FixedStructList> opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, IceUtil::Optional< ::Test::FixedStructList>& p3)
    {
        return opFixedStructList(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::FixedStructList> opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, IceUtil::Optional< ::Test::FixedStructList>& p3, const ::Ice::Context& __ctx)
    {
        return opFixedStructList(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFixedStructList(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFixedStructList(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opFixedStructList(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opFixedStructList(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1)
    {
        return begin_opFixedStructList(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opFixedStructList(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedStructList(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedStructList(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Test::Callback_Initial_opFixedStructListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedStructList(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opFixedStructListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opFixedStructList(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::FixedStructList> end_opFixedStructList(IceUtil::Optional< ::Test::FixedStructList>& p3, const ::Ice::AsyncResultPtr&);

     void ___end_opFixedStructList(IceUtil::Optional< ::std::vector< ::Test::FixedStruct> >& p3, IceUtil::Optional< ::std::vector< ::Test::FixedStruct> >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::FixedStructList> opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, IceUtil::Optional< ::Test::FixedStructList>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opFixedStructList(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::VarStructSeq> opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >& p1, IceUtil::Optional< ::Test::VarStructSeq>& p3)
    {
        return opVarStructSeq(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::VarStructSeq> opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >& p1, IceUtil::Optional< ::Test::VarStructSeq>& p3, const ::Ice::Context& __ctx)
    {
        return opVarStructSeq(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVarStructSeq(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVarStructSeq(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opVarStructSeq(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opVarStructSeq(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >& p1)
    {
        return begin_opVarStructSeq(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opVarStructSeq(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVarStructSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVarStructSeq(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >& p1, const ::Test::Callback_Initial_opVarStructSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVarStructSeq(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opVarStructSeqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opVarStructSeq(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::VarStructSeq> end_opVarStructSeq(IceUtil::Optional< ::Test::VarStructSeq>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::VarStructSeq> opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, IceUtil::Optional< ::Test::VarStructSeq>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opVarStructSeq(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::Serializable> opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, IceUtil::Optional< ::Test::Serializable>& p3)
    {
        return opSerializable(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::Serializable> opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, IceUtil::Optional< ::Test::Serializable>& p3, const ::Ice::Context& __ctx)
    {
        return opSerializable(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::Serializable>&, const IceUtil::Optional< ::Test::Serializable>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opSerializable(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opSerializable(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::Serializable>&, const IceUtil::Optional< ::Test::Serializable>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opSerializable(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opSerializable(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::Serializable>&, const IceUtil::Optional< ::Test::Serializable>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1)
    {
        return begin_opSerializable(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opSerializable(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSerializable(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSerializable(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Test::Callback_Initial_opSerializablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSerializable(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opSerializablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opSerializable(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::Serializable> end_opSerializable(IceUtil::Optional< ::Test::Serializable>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::Serializable> opSerializable(const IceUtil::Optional< ::Test::Serializable>&, IceUtil::Optional< ::Test::Serializable>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::IntIntDict> opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, IceUtil::Optional< ::Test::IntIntDict>& p3)
    {
        return opIntIntDict(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::IntIntDict> opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, IceUtil::Optional< ::Test::IntIntDict>& p3, const ::Ice::Context& __ctx)
    {
        return opIntIntDict(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::IntIntDict>&, const IceUtil::Optional< ::Test::IntIntDict>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opIntIntDict(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opIntIntDict(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::IntIntDict>&, const IceUtil::Optional< ::Test::IntIntDict>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opIntIntDict(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opIntIntDict(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::IntIntDict>&, const IceUtil::Optional< ::Test::IntIntDict>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1)
    {
        return begin_opIntIntDict(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opIntIntDict(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntIntDict(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntIntDict(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Test::Callback_Initial_opIntIntDictPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntIntDict(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opIntIntDictPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opIntIntDict(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::IntIntDict> end_opIntIntDict(IceUtil::Optional< ::Test::IntIntDict>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::IntIntDict> opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>&, IceUtil::Optional< ::Test::IntIntDict>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::StringIntDict> opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, IceUtil::Optional< ::Test::StringIntDict>& p3)
    {
        return opStringIntDict(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::StringIntDict> opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, IceUtil::Optional< ::Test::StringIntDict>& p3, const ::Ice::Context& __ctx)
    {
        return opStringIntDict(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringIntDict(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringIntDict(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opStringIntDict(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opStringIntDict(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1)
    {
        return begin_opStringIntDict(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& __ctx)
    {
        return begin_opStringIntDict(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringIntDict(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringIntDict(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Test::Callback_Initial_opStringIntDictPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringIntDict(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opStringIntDictPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opStringIntDict(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::StringIntDict> end_opStringIntDict(IceUtil::Optional< ::Test::StringIntDict>& p3, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::StringIntDict> opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>&, IceUtil::Optional< ::Test::StringIntDict>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    IceUtil::Optional< ::Test::CustomMap< ::Ice::Int, std::string> > opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p1, IceUtil::Optional< ::Test::CustomMap< ::Ice::Int, std::string> >& p3)
    {
        return opCustomIntStringDict(p1, p3, 0);
    }
    IceUtil::Optional< ::Test::CustomMap< ::Ice::Int, std::string> > opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p1, IceUtil::Optional< ::Test::CustomMap< ::Ice::Int, std::string> >& p3, const ::Ice::Context& __ctx)
    {
        return opCustomIntStringDict(p1, p3, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p1, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opCustomIntStringDict(p1, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p1, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opCustomIntStringDict(p1, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_opCustomIntStringDict(p1, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p1, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opCustomIntStringDict(p1, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p1, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p1)
    {
        return begin_opCustomIntStringDict(p1, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p1, const ::Ice::Context& __ctx)
    {
        return begin_opCustomIntStringDict(p1, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p1, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCustomIntStringDict(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p1, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCustomIntStringDict(p1, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p1, const ::Test::Callback_Initial_opCustomIntStringDictPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCustomIntStringDict(p1, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p1, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opCustomIntStringDictPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opCustomIntStringDict(p1, &__ctx, __del, __cookie);
    }

    IceUtil::Optional< ::Test::CustomMap< ::Ice::Int, std::string> > end_opCustomIntStringDict(IceUtil::Optional< ::Test::CustomMap< ::Ice::Int, std::string> >& p3, const ::Ice::AsyncResultPtr&);

     void ___end_opCustomIntStringDict(IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& p3, IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >& __ret, const ::Ice::AsyncResultPtr&);
    
private:

    IceUtil::Optional< ::Test::CustomMap< ::Ice::Int, std::string> > opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, IceUtil::Optional< ::Test::CustomMap< ::Ice::Int, std::string> >&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void opClassAndUnknownOptional(const ::Test::APtr& p)
    {
        opClassAndUnknownOptional(p, 0);
    }
    void opClassAndUnknownOptional(const ::Test::APtr& p, const ::Ice::Context& __ctx)
    {
        opClassAndUnknownOptional(p, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opClassAndUnknownOptional(p, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opClassAndUnknownOptional(p, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_opClassAndUnknownOptional(p, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_opClassAndUnknownOptional(p, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_opClassAndUnknownOptional(const ::Test::APtr& p)
    {
        return begin_opClassAndUnknownOptional(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::Ice::Context& __ctx)
    {
        return begin_opClassAndUnknownOptional(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opClassAndUnknownOptional(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opClassAndUnknownOptional(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::Test::Callback_Initial_opClassAndUnknownOptionalPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opClassAndUnknownOptional(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_opClassAndUnknownOptionalPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_opClassAndUnknownOptional(p, &__ctx, __del, __cookie);
    }

    void end_opClassAndUnknownOptional(const ::Ice::AsyncResultPtr&);
    
private:

    void opClassAndUnknownOptional(const ::Test::APtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_opClassAndUnknownOptional(const ::Test::APtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o)
    {
        sendOptionalClass(req, o, 0);
    }
    void sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx)
    {
        sendOptionalClass(req, o, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendOptionalClass(req, o, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendOptionalClass(req, o, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendOptionalClass(req, o, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendOptionalClass(req, o, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o)
    {
        return begin_sendOptionalClass(req, o, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx)
    {
        return begin_sendOptionalClass(req, o, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendOptionalClass(req, o, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendOptionalClass(req, o, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Test::Callback_Initial_sendOptionalClassPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendOptionalClass(req, o, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_sendOptionalClassPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendOptionalClass(req, o, &__ctx, __del, __cookie);
    }

    void end_sendOptionalClass(const ::Ice::AsyncResultPtr&);
    
private:

    void sendOptionalClass(bool, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendOptionalClass(bool, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void returnOptionalClass(bool req, IceUtil::Optional< ::Test::OneOptionalPtr>& o)
    {
        returnOptionalClass(req, o, 0);
    }
    void returnOptionalClass(bool req, IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& __ctx)
    {
        returnOptionalClass(req, o, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_returnOptionalClass(bool req, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::OneOptionalPtr>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_returnOptionalClass(req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_returnOptionalClass(bool req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_returnOptionalClass(req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_returnOptionalClass(bool req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::OneOptionalPtr>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_returnOptionalClass(req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_returnOptionalClass(bool req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_returnOptionalClass(req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_returnOptionalClass(bool req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const IceUtil::Optional< ::Test::OneOptionalPtr>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_returnOptionalClass(bool req)
    {
        return begin_returnOptionalClass(req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_returnOptionalClass(bool req, const ::Ice::Context& __ctx)
    {
        return begin_returnOptionalClass(req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_returnOptionalClass(bool req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnOptionalClass(req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_returnOptionalClass(bool req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnOptionalClass(req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_returnOptionalClass(bool req, const ::Test::Callback_Initial_returnOptionalClassPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnOptionalClass(req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_returnOptionalClass(bool req, const ::Ice::Context& __ctx, const ::Test::Callback_Initial_returnOptionalClassPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_returnOptionalClass(req, &__ctx, __del, __cookie);
    }

    void end_returnOptionalClass(IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::AsyncResultPtr&);
    
private:

    void returnOptionalClass(bool, IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_returnOptionalClass(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool supportsRequiredParams()
    {
        return supportsRequiredParams(0);
    }
    bool supportsRequiredParams(const ::Ice::Context& __ctx)
    {
        return supportsRequiredParams(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_supportsRequiredParams(const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_supportsRequiredParams(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_supportsRequiredParams(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_supportsRequiredParams(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_supportsRequiredParams(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_supportsRequiredParams(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_supportsRequiredParams(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_supportsRequiredParams(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_supportsRequiredParams(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_supportsRequiredParams()
    {
        return begin_supportsRequiredParams(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsRequiredParams(const ::Ice::Context& __ctx)
    {
        return begin_supportsRequiredParams(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsRequiredParams(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsRequiredParams(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsRequiredParams(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsRequiredParams(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsRequiredParams(const ::Test::Callback_Initial_supportsRequiredParamsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsRequiredParams(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsRequiredParams(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_supportsRequiredParamsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsRequiredParams(&__ctx, __del, __cookie);
    }

    bool end_supportsRequiredParams(const ::Ice::AsyncResultPtr&);
    
private:

    bool supportsRequiredParams(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_supportsRequiredParams(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool supportsJavaSerializable()
    {
        return supportsJavaSerializable(0);
    }
    bool supportsJavaSerializable(const ::Ice::Context& __ctx)
    {
        return supportsJavaSerializable(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_supportsJavaSerializable(const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_supportsJavaSerializable(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_supportsJavaSerializable(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_supportsJavaSerializable(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_supportsJavaSerializable(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_supportsJavaSerializable(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_supportsJavaSerializable(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_supportsJavaSerializable(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_supportsJavaSerializable(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_supportsJavaSerializable()
    {
        return begin_supportsJavaSerializable(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsJavaSerializable(const ::Ice::Context& __ctx)
    {
        return begin_supportsJavaSerializable(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsJavaSerializable(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsJavaSerializable(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsJavaSerializable(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsJavaSerializable(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsJavaSerializable(const ::Test::Callback_Initial_supportsJavaSerializablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsJavaSerializable(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsJavaSerializable(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_supportsJavaSerializablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsJavaSerializable(&__ctx, __del, __cookie);
    }

    bool end_supportsJavaSerializable(const ::Ice::AsyncResultPtr&);
    
private:

    bool supportsJavaSerializable(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_supportsJavaSerializable(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool supportsCsharpSerializable()
    {
        return supportsCsharpSerializable(0);
    }
    bool supportsCsharpSerializable(const ::Ice::Context& __ctx)
    {
        return supportsCsharpSerializable(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_supportsCsharpSerializable(const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_supportsCsharpSerializable(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_supportsCsharpSerializable(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_supportsCsharpSerializable(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_supportsCsharpSerializable(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_supportsCsharpSerializable(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_supportsCsharpSerializable(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_supportsCsharpSerializable(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_supportsCsharpSerializable(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_supportsCsharpSerializable()
    {
        return begin_supportsCsharpSerializable(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsCsharpSerializable(const ::Ice::Context& __ctx)
    {
        return begin_supportsCsharpSerializable(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsCsharpSerializable(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsCsharpSerializable(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCsharpSerializable(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsCsharpSerializable(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCsharpSerializable(const ::Test::Callback_Initial_supportsCsharpSerializablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsCsharpSerializable(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCsharpSerializable(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_supportsCsharpSerializablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsCsharpSerializable(&__ctx, __del, __cookie);
    }

    bool end_supportsCsharpSerializable(const ::Ice::AsyncResultPtr&);
    
private:

    bool supportsCsharpSerializable(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_supportsCsharpSerializable(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool supportsCppStringView()
    {
        return supportsCppStringView(0);
    }
    bool supportsCppStringView(const ::Ice::Context& __ctx)
    {
        return supportsCppStringView(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_supportsCppStringView(const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_supportsCppStringView(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_supportsCppStringView(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_supportsCppStringView(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_supportsCppStringView(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_supportsCppStringView(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_supportsCppStringView(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_supportsCppStringView(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_supportsCppStringView(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_supportsCppStringView()
    {
        return begin_supportsCppStringView(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsCppStringView(const ::Ice::Context& __ctx)
    {
        return begin_supportsCppStringView(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsCppStringView(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsCppStringView(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCppStringView(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsCppStringView(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCppStringView(const ::Test::Callback_Initial_supportsCppStringViewPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsCppStringView(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCppStringView(const ::Ice::Context& __ctx, const ::Test::Callback_Initial_supportsCppStringViewPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_supportsCppStringView(&__ctx, __del, __cookie);
    }

    bool end_supportsCppStringView(const ::Ice::AsyncResultPtr&);
    
private:

    bool supportsCppStringView(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_supportsCppStringView(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<Initial> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_secure(bool __secure) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_twoway() const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_oneway() const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_batchOneway() const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_datagram() const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_batchDatagram() const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_compress(bool __compress) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Initial> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Initial*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace Test
{

class OneOptional : virtual public ::Ice::Object
{
public:

    typedef OneOptionalPrx ProxyType;
    typedef OneOptionalPtr PointerType;

    OneOptional()
    {
    }

    explicit OneOptional(const IceUtil::Optional< ::Ice::Int>& __ice_a) :
        a(__ice_a)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static ::Ice::ObjectFactoryPtr ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    IceUtil::Optional< ::Ice::Int> a;

protected:

    virtual ~OneOptional() {}

    friend class OneOptional__staticInit;
};

class OneOptional__staticInit
{
public:

    ::Test::OneOptional _init;
};

static OneOptional__staticInit _OneOptional_init;

inline bool operator==(const OneOptional& l, const OneOptional& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const OneOptional& l, const OneOptional& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class MultiOptional : virtual public ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef MultiOptionalPrx ProxyType;
    typedef MultiOptionalPtr PointerType;

    MultiOptional()
    {
    }

    MultiOptional(const IceUtil::Optional< ::Ice::Byte>& __ice_a, const IceUtil::Optional<bool>& __ice_b, const IceUtil::Optional< ::Ice::Short>& __ice_c, const IceUtil::Optional< ::Ice::Int>& __ice_d, const IceUtil::Optional< ::Ice::Long>& __ice_e, const IceUtil::Optional< ::Ice::Float>& __ice_f, const IceUtil::Optional< ::Ice::Double>& __ice_g, const IceUtil::Optional< ::std::string>& __ice_h, const IceUtil::Optional< ::Test::MyEnum>& __ice_i, const IceUtil::Optional< ::Test::MultiOptionalPrx>& __ice_j, const IceUtil::Optional< ::Test::MultiOptionalPtr>& __ice_k, const IceUtil::Optional< ::Test::ByteSeq>& __ice_bs, const IceUtil::Optional< ::Test::StringSeq>& __ice_ss, const IceUtil::Optional< ::Test::IntIntDict>& __ice_iid, const IceUtil::Optional< ::Test::StringIntDict>& __ice_sid, const IceUtil::Optional< ::Test::FixedStruct>& __ice_fs, const IceUtil::Optional< ::Test::VarStruct>& __ice_vs, const IceUtil::Optional< ::Test::ShortSeq>& __ice_shs, const IceUtil::Optional< ::Test::MyEnumSeq>& __ice_es, const IceUtil::Optional< ::Test::FixedStructSeq>& __ice_fss, const IceUtil::Optional< ::Test::VarStructSeq>& __ice_vss, const IceUtil::Optional< ::Test::OneOptionalSeq>& __ice_oos, const IceUtil::Optional< ::Test::OneOptionalPrxSeq>& __ice_oops, const IceUtil::Optional< ::Test::IntEnumDict>& __ice_ied, const IceUtil::Optional< ::Test::IntFixedStructDict>& __ice_ifsd, const IceUtil::Optional< ::Test::IntVarStructDict>& __ice_ivsd, const IceUtil::Optional< ::Test::IntOneOptionalDict>& __ice_iood, const IceUtil::Optional< ::Test::IntOneOptionalPrxDict>& __ice_ioopd, const IceUtil::Optional< ::Test::BoolSeq>& __ice_bos, const IceUtil::Optional< ::Test::Serializable>& __ice_ser) :
        a(__ice_a),
        b(__ice_b),
        c(__ice_c),
        d(__ice_d),
        e(__ice_e),
        f(__ice_f),
        g(__ice_g),
        h(__ice_h),
        i(__ice_i),
        j(__ice_j),
        k(__ice_k),
        bs(__ice_bs),
        ss(__ice_ss),
        iid(__ice_iid),
        sid(__ice_sid),
        fs(__ice_fs),
        vs(__ice_vs),
        shs(__ice_shs),
        es(__ice_es),
        fss(__ice_fss),
        vss(__ice_vss),
        oos(__ice_oos),
        oops(__ice_oops),
        ied(__ice_ied),
        ifsd(__ice_ifsd),
        ivsd(__ice_ivsd),
        iood(__ice_iood),
        ioopd(__ice_ioopd),
        bos(__ice_bos),
        ser(__ice_ser)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __gcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ObjectFactoryPtr ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    IceUtil::Optional< ::Ice::Byte> a;

    IceUtil::Optional<bool> b;

    IceUtil::Optional< ::Ice::Short> c;

    IceUtil::Optional< ::Ice::Int> d;

    IceUtil::Optional< ::Ice::Long> e;

    IceUtil::Optional< ::Ice::Float> f;

    IceUtil::Optional< ::Ice::Double> g;

    IceUtil::Optional< ::std::string> h;

    IceUtil::Optional< ::Test::MyEnum> i;

    IceUtil::Optional< ::Test::MultiOptionalPrx> j;

    IceUtil::Optional< ::Test::MultiOptionalPtr> k;

    IceUtil::Optional< ::Test::ByteSeq> bs;

    IceUtil::Optional< ::Test::StringSeq> ss;

    IceUtil::Optional< ::Test::IntIntDict> iid;

    IceUtil::Optional< ::Test::StringIntDict> sid;

    IceUtil::Optional< ::Test::FixedStruct> fs;

    IceUtil::Optional< ::Test::VarStruct> vs;

    IceUtil::Optional< ::Test::ShortSeq> shs;

    IceUtil::Optional< ::Test::MyEnumSeq> es;

    IceUtil::Optional< ::Test::FixedStructSeq> fss;

    IceUtil::Optional< ::Test::VarStructSeq> vss;

    IceUtil::Optional< ::Test::OneOptionalSeq> oos;

    IceUtil::Optional< ::Test::OneOptionalPrxSeq> oops;

    IceUtil::Optional< ::Test::IntEnumDict> ied;

    IceUtil::Optional< ::Test::IntFixedStructDict> ifsd;

    IceUtil::Optional< ::Test::IntVarStructDict> ivsd;

    IceUtil::Optional< ::Test::IntOneOptionalDict> iood;

    IceUtil::Optional< ::Test::IntOneOptionalPrxDict> ioopd;

    IceUtil::Optional< ::Test::BoolSeq> bos;

    IceUtil::Optional< ::Test::Serializable> ser;

protected:

    virtual ~MultiOptional() {}
};

inline bool operator==(const MultiOptional& l, const MultiOptional& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MultiOptional& l, const MultiOptional& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class A : virtual public ::Ice::Object
{
public:

    typedef APrx ProxyType;
    typedef APtr PointerType;

    A() :
        requiredA(0)
    {
    }

    A(::Ice::Int __ice_requiredA, const IceUtil::Optional< ::Ice::Int>& __ice_ma, const IceUtil::Optional< ::Ice::Int>& __ice_mb, const IceUtil::Optional< ::Ice::Int>& __ice_mc) :
        requiredA(__ice_requiredA),
        ma(__ice_ma),
        mb(__ice_mb),
        mc(__ice_mc)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static ::Ice::ObjectFactoryPtr ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Ice::Int requiredA;

    IceUtil::Optional< ::Ice::Int> ma;

    IceUtil::Optional< ::Ice::Int> mb;

    IceUtil::Optional< ::Ice::Int> mc;

protected:

    virtual ~A() {}
};

inline bool operator==(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const A& l, const A& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class B : public ::Test::A, public ::IceInternal::GCObject
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    B() :
        requiredB(0)
    {
    }

    B(::Ice::Int __ice_requiredA, const IceUtil::Optional< ::Ice::Int>& __ice_ma, const IceUtil::Optional< ::Ice::Int>& __ice_mb, const IceUtil::Optional< ::Ice::Int>& __ice_mc, ::Ice::Int __ice_requiredB, const IceUtil::Optional< ::Ice::Int>& __ice_md) :
        ::Test::A(__ice_requiredA, __ice_ma, __ice_mb, __ice_mc)
        ,
        requiredB(__ice_requiredB),
        md(__ice_md)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __gcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ObjectFactoryPtr ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::A::__write;
    using ::Test::A::__read;
    #endif

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::A::__writeImpl;
    using ::Test::A::__readImpl;
    #endif

public:

    ::Ice::Int requiredB;

    IceUtil::Optional< ::Ice::Int> md;

protected:

    virtual ~B() {}

    ::Ice::SlicedDataPtr __slicedData;
};

inline bool operator==(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const B& l, const B& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class C : public ::Test::B
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    C()
    {
    }

    C(::Ice::Int __ice_requiredA, const IceUtil::Optional< ::Ice::Int>& __ice_ma, const IceUtil::Optional< ::Ice::Int>& __ice_mb, const IceUtil::Optional< ::Ice::Int>& __ice_mc, ::Ice::Int __ice_requiredB, const IceUtil::Optional< ::Ice::Int>& __ice_md, const ::std::string& __ice_ss, const IceUtil::Optional< ::std::string>& __ice_ms) :
        ::Test::B(__ice_requiredA, __ice_ma, __ice_mb, __ice_mc, __ice_requiredB, __ice_md)
        ,
        ss(__ice_ss),
        ms(__ice_ms)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static ::Ice::ObjectFactoryPtr ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::B::__writeImpl;
    using ::Test::B::__readImpl;
    #endif

public:

    ::std::string ss;

    IceUtil::Optional< ::std::string> ms;

protected:

    virtual ~C() {}
};

inline bool operator==(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const C& l, const C& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class WD : virtual public ::Ice::Object
{
public:

    typedef WDPrx ProxyType;
    typedef WDPtr PointerType;

    WD() :
        a(5),
        s("test")
    {
    }

    WD(const IceUtil::Optional< ::Ice::Int>& __ice_a, const IceUtil::Optional< ::std::string>& __ice_s) :
        a(__ice_a),
        s(__ice_s)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static ::Ice::ObjectFactoryPtr ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    IceUtil::Optional< ::Ice::Int> a;

    IceUtil::Optional< ::std::string> s;

protected:

    virtual ~WD() {}
};

inline bool operator==(const WD& l, const WD& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const WD& l, const WD& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class OptionalWithCustom : virtual public ::Ice::Object
{
public:

    typedef OptionalWithCustomPrx ProxyType;
    typedef OptionalWithCustomPtr PointerType;

    OptionalWithCustom()
    {
    }

    OptionalWithCustom(const IceUtil::Optional< ::Test::SmallStructList>& __ice_l, const IceUtil::Optional< ::Test::SmallStructList>& __ice_lp, const IceUtil::Optional< ::Test::ClassVarStructPtr>& __ice_s) :
        l(__ice_l),
        lp(__ice_lp),
        s(__ice_s)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static ::Ice::ObjectFactoryPtr ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    IceUtil::Optional< ::Test::SmallStructList> l;

protected:

    IceUtil::Optional< ::Test::SmallStructList> lp;

public:

    IceUtil::Optional< ::Test::ClassVarStructPtr> s;

protected:

    virtual ~OptionalWithCustom() {}
};

inline bool operator==(const OptionalWithCustom& l, const OptionalWithCustom& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const OptionalWithCustom& l, const OptionalWithCustom& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class E : virtual public ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef EPrx ProxyType;
    typedef EPtr PointerType;

    E()
    {
    }

    explicit E(const ::Test::APtr& __ice_ae) :
        ae(__ice_ae)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __gcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ObjectFactoryPtr ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Test::APtr ae;

protected:

    virtual ~E() {}
};

inline bool operator==(const E& l, const E& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const E& l, const E& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class F : public ::Test::E
{
public:

    typedef FPrx ProxyType;
    typedef FPtr PointerType;

    F()
    {
    }

    F(const ::Test::APtr& __ice_ae, const IceUtil::Optional< ::Test::APtr>& __ice_af) :
        ::Test::E(__ice_ae)
        ,
        af(__ice_af)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __gcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ObjectFactoryPtr ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Test::E::__writeImpl;
    using ::Test::E::__readImpl;
    #endif

public:

    IceUtil::Optional< ::Test::APtr> af;

protected:

    virtual ~F() {}
};

inline bool operator==(const F& l, const F& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const F& l, const F& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Recursive : virtual public ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef RecursivePrx ProxyType;
    typedef RecursivePtr PointerType;

    Recursive()
    {
    }

    explicit Recursive(const IceUtil::Optional< ::Test::RecursiveSeq>& __ice_value) :
        value(__ice_value)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __gcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ObjectFactoryPtr ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    IceUtil::Optional< ::Test::RecursiveSeq> value;

protected:

    virtual ~Recursive() {}
};

inline bool operator==(const Recursive& l, const Recursive& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Recursive& l, const Recursive& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Initial : virtual public ::Ice::Object
{
public:

    typedef InitialPrx ProxyType;
    typedef InitialPtr PointerType;

    Initial()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void shutdown_async(const ::Test::AMD_Initial_shutdownPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___shutdown(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void pingPong_async(const ::Test::AMD_Initial_pingPongPtr&, const ::Ice::ObjectPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___pingPong(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opOptionalException_async(const ::Test::AMD_Initial_opOptionalExceptionPtr&, const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opOptionalException(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opDerivedException_async(const ::Test::AMD_Initial_opDerivedExceptionPtr&, const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opDerivedException(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opRequiredException_async(const ::Test::AMD_Initial_opRequiredExceptionPtr&, const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opRequiredException(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opByte_async(const ::Test::AMD_Initial_opBytePtr&, const IceUtil::Optional< ::Ice::Byte>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opByte(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opBool_async(const ::Test::AMD_Initial_opBoolPtr&, const IceUtil::Optional<bool>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBool(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opShort_async(const ::Test::AMD_Initial_opShortPtr&, const IceUtil::Optional< ::Ice::Short>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opShort(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opInt_async(const ::Test::AMD_Initial_opIntPtr&, const IceUtil::Optional< ::Ice::Int>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opInt(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opLong_async(const ::Test::AMD_Initial_opLongPtr&, const IceUtil::Optional< ::Ice::Long>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opLong(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opFloat_async(const ::Test::AMD_Initial_opFloatPtr&, const IceUtil::Optional< ::Ice::Float>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opFloat(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opDouble_async(const ::Test::AMD_Initial_opDoublePtr&, const IceUtil::Optional< ::Ice::Double>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opDouble(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opString_async(const ::Test::AMD_Initial_opStringPtr&, const IceUtil::Optional< ::std::string>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opString(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opCustomString_async(const ::Test::AMD_Initial_opCustomStringPtr&, const IceUtil::Optional<Util::string_view>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opCustomString(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opMyEnum_async(const ::Test::AMD_Initial_opMyEnumPtr&, const IceUtil::Optional< ::Test::MyEnum>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opMyEnum(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opSmallStruct_async(const ::Test::AMD_Initial_opSmallStructPtr&, const IceUtil::Optional< ::Test::SmallStruct>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opSmallStruct(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opFixedStruct_async(const ::Test::AMD_Initial_opFixedStructPtr&, const IceUtil::Optional< ::Test::FixedStruct>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opFixedStruct(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opVarStruct_async(const ::Test::AMD_Initial_opVarStructPtr&, const IceUtil::Optional< ::Test::VarStruct>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opVarStruct(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opOneOptional_async(const ::Test::AMD_Initial_opOneOptionalPtr&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opOneOptional(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opOneOptionalProxy_async(const ::Test::AMD_Initial_opOneOptionalProxyPtr&, const IceUtil::Optional< ::Test::OneOptionalPrx>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opOneOptionalProxy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opByteSeq_async(const ::Test::AMD_Initial_opByteSeqPtr&, const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opBoolSeq_async(const ::Test::AMD_Initial_opBoolSeqPtr&, const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opShortSeq_async(const ::Test::AMD_Initial_opShortSeqPtr&, const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opShortSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opIntSeq_async(const ::Test::AMD_Initial_opIntSeqPtr&, const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opIntSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opLongSeq_async(const ::Test::AMD_Initial_opLongSeqPtr&, const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opLongSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opFloatSeq_async(const ::Test::AMD_Initial_opFloatSeqPtr&, const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opFloatSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opDoubleSeq_async(const ::Test::AMD_Initial_opDoubleSeqPtr&, const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opDoubleSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opStringSeq_async(const ::Test::AMD_Initial_opStringSeqPtr&, const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opSmallStructSeq_async(const ::Test::AMD_Initial_opSmallStructSeqPtr&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opSmallStructSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opSmallStructList_async(const ::Test::AMD_Initial_opSmallStructListPtr&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opSmallStructList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opFixedStructSeq_async(const ::Test::AMD_Initial_opFixedStructSeqPtr&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opFixedStructSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opFixedStructList_async(const ::Test::AMD_Initial_opFixedStructListPtr&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opFixedStructList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opVarStructSeq_async(const ::Test::AMD_Initial_opVarStructSeqPtr&, const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opVarStructSeq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opSerializable_async(const ::Test::AMD_Initial_opSerializablePtr&, const IceUtil::Optional< ::Test::Serializable>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opSerializable(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opIntIntDict_async(const ::Test::AMD_Initial_opIntIntDictPtr&, const IceUtil::Optional< ::Test::IntIntDict>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opIntIntDict(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opStringIntDict_async(const ::Test::AMD_Initial_opStringIntDictPtr&, const IceUtil::Optional< ::Test::StringIntDict>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opStringIntDict(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opCustomIntStringDict_async(const ::Test::AMD_Initial_opCustomIntStringDictPtr&, const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opCustomIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void opClassAndUnknownOptional_async(const ::Test::AMD_Initial_opClassAndUnknownOptionalPtr&, const ::Test::APtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___opClassAndUnknownOptional(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void sendOptionalClass_async(const ::Test::AMD_Initial_sendOptionalClassPtr&, bool, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendOptionalClass(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void returnOptionalClass_async(const ::Test::AMD_Initial_returnOptionalClassPtr&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___returnOptionalClass(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void supportsRequiredParams_async(const ::Test::AMD_Initial_supportsRequiredParamsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___supportsRequiredParams(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void supportsJavaSerializable_async(const ::Test::AMD_Initial_supportsJavaSerializablePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___supportsJavaSerializable(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void supportsCsharpSerializable_async(const ::Test::AMD_Initial_supportsCsharpSerializablePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___supportsCsharpSerializable(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void supportsCppStringView_async(const ::Test::AMD_Initial_supportsCppStringViewPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___supportsCppStringView(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Initial& l, const Initial& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Initial& l, const Initial& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Test
{

template<class T>
class CallbackNC_Initial_shutdown : public Callback_Initial_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_shutdown : public Callback_Initial_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_pingPong : public Callback_Initial_pingPong_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ObjectPtr&);

    CallbackNC_Initial_pingPong(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Ice::ObjectPtr __ret;
        try
        {
            __ret = __proxy->end_pingPong(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_pingPongPtr
newCallback_Initial_pingPong(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_pingPong<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_pingPongPtr
newCallback_Initial_pingPong(T* instance, void (T::*cb)(const ::Ice::ObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_pingPong<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_pingPong : public Callback_Initial_pingPong_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ObjectPtr&, const CT&);

    Callback_Initial_pingPong(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        ::Ice::ObjectPtr __ret;
        try
        {
            __ret = __proxy->end_pingPong(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_pingPongPtr
newCallback_Initial_pingPong(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_pingPong<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_pingPongPtr
newCallback_Initial_pingPong(T* instance, void (T::*cb)(const ::Ice::ObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_pingPong<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opOptionalException : public Callback_Initial_opOptionalException_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_opOptionalException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_opOptionalException(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOptionalException<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOptionalException<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOptionalException<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOptionalException<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opOptionalException : public Callback_Initial_opOptionalException_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_opOptionalException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_opOptionalException(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOptionalException<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOptionalException<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOptionalException<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOptionalException<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opDerivedException : public Callback_Initial_opDerivedException_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_opDerivedException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_opDerivedException(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDerivedException<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDerivedException<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDerivedException<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDerivedException<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opDerivedException : public Callback_Initial_opDerivedException_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_opDerivedException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_opDerivedException(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDerivedException<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDerivedException<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDerivedException<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDerivedException<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opRequiredException : public Callback_Initial_opRequiredException_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_opRequiredException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_opRequiredException(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opRequiredException<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opRequiredException<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opRequiredException<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opRequiredException<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opRequiredException : public Callback_Initial_opRequiredException_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_opRequiredException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_opRequiredException(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opRequiredException<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opRequiredException<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opRequiredException<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opRequiredException<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opByte : public Callback_Initial_opByte_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&);

    CallbackNC_Initial_opByte(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Byte> p3;
        IceUtil::Optional< ::Ice::Byte> __ret;
        try
        {
            __ret = __proxy->end_opByte(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opBytePtr
newCallback_Initial_opByte(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opByte<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opBytePtr
newCallback_Initial_opByte(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opByte<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opByte : public Callback_Initial_opByte_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&, const CT&);

    Callback_Initial_opByte(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Byte> p3;
        IceUtil::Optional< ::Ice::Byte> __ret;
        try
        {
            __ret = __proxy->end_opByte(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opBytePtr
newCallback_Initial_opByte(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opByte<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opBytePtr
newCallback_Initial_opByte(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opByte<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opBool : public Callback_Initial_opBool_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&);

    CallbackNC_Initial_opBool(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional<bool> p3;
        IceUtil::Optional<bool> __ret;
        try
        {
            __ret = __proxy->end_opBool(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opBoolPtr
newCallback_Initial_opBool(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBool<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opBoolPtr
newCallback_Initial_opBool(T* instance, void (T::*cb)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBool<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opBool : public Callback_Initial_opBool_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&, const CT&);

    Callback_Initial_opBool(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional<bool> p3;
        IceUtil::Optional<bool> __ret;
        try
        {
            __ret = __proxy->end_opBool(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opBoolPtr
newCallback_Initial_opBool(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBool<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opBoolPtr
newCallback_Initial_opBool(T* instance, void (T::*cb)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBool<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opShort : public Callback_Initial_opShort_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&);

    CallbackNC_Initial_opShort(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Short> p3;
        IceUtil::Optional< ::Ice::Short> __ret;
        try
        {
            __ret = __proxy->end_opShort(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opShortPtr
newCallback_Initial_opShort(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opShort<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opShortPtr
newCallback_Initial_opShort(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opShort<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opShort : public Callback_Initial_opShort_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&, const CT&);

    Callback_Initial_opShort(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Short> p3;
        IceUtil::Optional< ::Ice::Short> __ret;
        try
        {
            __ret = __proxy->end_opShort(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opShortPtr
newCallback_Initial_opShort(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opShort<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opShortPtr
newCallback_Initial_opShort(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opShort<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opInt : public Callback_Initial_opInt_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&);

    CallbackNC_Initial_opInt(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Int> p3;
        IceUtil::Optional< ::Ice::Int> __ret;
        try
        {
            __ret = __proxy->end_opInt(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opIntPtr
newCallback_Initial_opInt(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opInt<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opIntPtr
newCallback_Initial_opInt(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opInt<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opInt : public Callback_Initial_opInt_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&, const CT&);

    Callback_Initial_opInt(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Int> p3;
        IceUtil::Optional< ::Ice::Int> __ret;
        try
        {
            __ret = __proxy->end_opInt(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opIntPtr
newCallback_Initial_opInt(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opInt<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opIntPtr
newCallback_Initial_opInt(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opInt<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opLong : public Callback_Initial_opLong_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&);

    CallbackNC_Initial_opLong(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Long> p3;
        IceUtil::Optional< ::Ice::Long> __ret;
        try
        {
            __ret = __proxy->end_opLong(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opLongPtr
newCallback_Initial_opLong(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opLong<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opLongPtr
newCallback_Initial_opLong(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opLong<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opLong : public Callback_Initial_opLong_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&, const CT&);

    Callback_Initial_opLong(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Long> p3;
        IceUtil::Optional< ::Ice::Long> __ret;
        try
        {
            __ret = __proxy->end_opLong(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opLongPtr
newCallback_Initial_opLong(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opLong<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opLongPtr
newCallback_Initial_opLong(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opLong<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opFloat : public Callback_Initial_opFloat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&);

    CallbackNC_Initial_opFloat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Float> p3;
        IceUtil::Optional< ::Ice::Float> __ret;
        try
        {
            __ret = __proxy->end_opFloat(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opFloatPtr
newCallback_Initial_opFloat(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFloat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opFloatPtr
newCallback_Initial_opFloat(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFloat<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opFloat : public Callback_Initial_opFloat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&, const CT&);

    Callback_Initial_opFloat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Float> p3;
        IceUtil::Optional< ::Ice::Float> __ret;
        try
        {
            __ret = __proxy->end_opFloat(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opFloatPtr
newCallback_Initial_opFloat(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFloat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opFloatPtr
newCallback_Initial_opFloat(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFloat<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opDouble : public Callback_Initial_opDouble_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&);

    CallbackNC_Initial_opDouble(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Double> p3;
        IceUtil::Optional< ::Ice::Double> __ret;
        try
        {
            __ret = __proxy->end_opDouble(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opDoublePtr
newCallback_Initial_opDouble(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDouble<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opDoublePtr
newCallback_Initial_opDouble(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDouble<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opDouble : public Callback_Initial_opDouble_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&, const CT&);

    Callback_Initial_opDouble(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Ice::Double> p3;
        IceUtil::Optional< ::Ice::Double> __ret;
        try
        {
            __ret = __proxy->end_opDouble(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opDoublePtr
newCallback_Initial_opDouble(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDouble<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opDoublePtr
newCallback_Initial_opDouble(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDouble<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opString : public Callback_Initial_opString_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&);

    CallbackNC_Initial_opString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::string> p3;
        IceUtil::Optional< ::std::string> __ret;
        try
        {
            __ret = __proxy->end_opString(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opStringPtr
newCallback_Initial_opString(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opString<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opStringPtr
newCallback_Initial_opString(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opString<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opString : public Callback_Initial_opString_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const CT&);

    Callback_Initial_opString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::string> p3;
        IceUtil::Optional< ::std::string> __ret;
        try
        {
            __ret = __proxy->end_opString(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opStringPtr
newCallback_Initial_opString(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opString<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opStringPtr
newCallback_Initial_opString(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opString<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opCustomString : public Callback_Initial_opCustomString_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<Util::string_view>&, const IceUtil::Optional<Util::string_view>&);

    CallbackNC_Initial_opCustomString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional<Util::string_view> p3;
        IceUtil::Optional<Util::string_view> __ret;
        try
        {
            __proxy->___end_opCustomString(p3, __ret, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opCustomStringPtr
newCallback_Initial_opCustomString(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<Util::string_view>&, const IceUtil::Optional<Util::string_view>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opCustomString<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opCustomStringPtr
newCallback_Initial_opCustomString(T* instance, void (T::*cb)(const IceUtil::Optional<Util::string_view>&, const IceUtil::Optional<Util::string_view>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opCustomString<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opCustomString : public Callback_Initial_opCustomString_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<Util::string_view>&, const IceUtil::Optional<Util::string_view>&, const CT&);

    Callback_Initial_opCustomString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional<Util::string_view> p3;
        IceUtil::Optional<Util::string_view> __ret;
        try
        {
            __proxy->___end_opCustomString(p3, __ret, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opCustomStringPtr
newCallback_Initial_opCustomString(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<Util::string_view>&, const IceUtil::Optional<Util::string_view>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opCustomString<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opCustomStringPtr
newCallback_Initial_opCustomString(T* instance, void (T::*cb)(const IceUtil::Optional<Util::string_view>&, const IceUtil::Optional<Util::string_view>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opCustomString<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opMyEnum : public Callback_Initial_opMyEnum_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::MyEnum>&, const IceUtil::Optional< ::Test::MyEnum>&);

    CallbackNC_Initial_opMyEnum(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::MyEnum> p3;
        IceUtil::Optional< ::Test::MyEnum> __ret;
        try
        {
            __ret = __proxy->end_opMyEnum(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opMyEnumPtr
newCallback_Initial_opMyEnum(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::MyEnum>&, const IceUtil::Optional< ::Test::MyEnum>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMyEnum<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opMyEnumPtr
newCallback_Initial_opMyEnum(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::MyEnum>&, const IceUtil::Optional< ::Test::MyEnum>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMyEnum<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opMyEnum : public Callback_Initial_opMyEnum_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::MyEnum>&, const IceUtil::Optional< ::Test::MyEnum>&, const CT&);

    Callback_Initial_opMyEnum(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::MyEnum> p3;
        IceUtil::Optional< ::Test::MyEnum> __ret;
        try
        {
            __ret = __proxy->end_opMyEnum(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opMyEnumPtr
newCallback_Initial_opMyEnum(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::MyEnum>&, const IceUtil::Optional< ::Test::MyEnum>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMyEnum<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opMyEnumPtr
newCallback_Initial_opMyEnum(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::MyEnum>&, const IceUtil::Optional< ::Test::MyEnum>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMyEnum<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opSmallStruct : public Callback_Initial_opSmallStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&);

    CallbackNC_Initial_opSmallStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::SmallStruct> p3;
        IceUtil::Optional< ::Test::SmallStruct> __ret;
        try
        {
            __ret = __proxy->end_opSmallStruct(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opSmallStructPtr
newCallback_Initial_opSmallStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStruct<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opSmallStructPtr
newCallback_Initial_opSmallStruct(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStruct<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opSmallStruct : public Callback_Initial_opSmallStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&, const CT&);

    Callback_Initial_opSmallStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::SmallStruct> p3;
        IceUtil::Optional< ::Test::SmallStruct> __ret;
        try
        {
            __ret = __proxy->end_opSmallStruct(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opSmallStructPtr
newCallback_Initial_opSmallStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStruct<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opSmallStructPtr
newCallback_Initial_opSmallStruct(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStruct<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opFixedStruct : public Callback_Initial_opFixedStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::FixedStruct>&, const IceUtil::Optional< ::Test::FixedStruct>&);

    CallbackNC_Initial_opFixedStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::FixedStruct> p3;
        IceUtil::Optional< ::Test::FixedStruct> __ret;
        try
        {
            __ret = __proxy->end_opFixedStruct(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opFixedStructPtr
newCallback_Initial_opFixedStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::FixedStruct>&, const IceUtil::Optional< ::Test::FixedStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStruct<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opFixedStructPtr
newCallback_Initial_opFixedStruct(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::FixedStruct>&, const IceUtil::Optional< ::Test::FixedStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStruct<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opFixedStruct : public Callback_Initial_opFixedStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::FixedStruct>&, const IceUtil::Optional< ::Test::FixedStruct>&, const CT&);

    Callback_Initial_opFixedStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::FixedStruct> p3;
        IceUtil::Optional< ::Test::FixedStruct> __ret;
        try
        {
            __ret = __proxy->end_opFixedStruct(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opFixedStructPtr
newCallback_Initial_opFixedStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::FixedStruct>&, const IceUtil::Optional< ::Test::FixedStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStruct<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opFixedStructPtr
newCallback_Initial_opFixedStruct(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::FixedStruct>&, const IceUtil::Optional< ::Test::FixedStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStruct<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opVarStruct : public Callback_Initial_opVarStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::VarStruct>&, const IceUtil::Optional< ::Test::VarStruct>&);

    CallbackNC_Initial_opVarStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::VarStruct> p3;
        IceUtil::Optional< ::Test::VarStruct> __ret;
        try
        {
            __ret = __proxy->end_opVarStruct(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opVarStructPtr
newCallback_Initial_opVarStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::VarStruct>&, const IceUtil::Optional< ::Test::VarStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVarStruct<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opVarStructPtr
newCallback_Initial_opVarStruct(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::VarStruct>&, const IceUtil::Optional< ::Test::VarStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVarStruct<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opVarStruct : public Callback_Initial_opVarStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::VarStruct>&, const IceUtil::Optional< ::Test::VarStruct>&, const CT&);

    Callback_Initial_opVarStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::VarStruct> p3;
        IceUtil::Optional< ::Test::VarStruct> __ret;
        try
        {
            __ret = __proxy->end_opVarStruct(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opVarStructPtr
newCallback_Initial_opVarStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::VarStruct>&, const IceUtil::Optional< ::Test::VarStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVarStruct<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opVarStructPtr
newCallback_Initial_opVarStruct(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::VarStruct>&, const IceUtil::Optional< ::Test::VarStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVarStruct<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opOneOptional : public Callback_Initial_opOneOptional_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&);

    CallbackNC_Initial_opOneOptional(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::OneOptionalPtr> p3;
        IceUtil::Optional< ::Test::OneOptionalPtr> __ret;
        try
        {
            __ret = __proxy->end_opOneOptional(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opOneOptionalPtr
newCallback_Initial_opOneOptional(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOneOptional<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opOneOptionalPtr
newCallback_Initial_opOneOptional(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOneOptional<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opOneOptional : public Callback_Initial_opOneOptional_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const CT&);

    Callback_Initial_opOneOptional(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::OneOptionalPtr> p3;
        IceUtil::Optional< ::Test::OneOptionalPtr> __ret;
        try
        {
            __ret = __proxy->end_opOneOptional(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opOneOptionalPtr
newCallback_Initial_opOneOptional(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOneOptional<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opOneOptionalPtr
newCallback_Initial_opOneOptional(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOneOptional<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opOneOptionalProxy : public Callback_Initial_opOneOptionalProxy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::OneOptionalPrx>&, const IceUtil::Optional< ::Test::OneOptionalPrx>&);

    CallbackNC_Initial_opOneOptionalProxy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::OneOptionalPrx> p3;
        IceUtil::Optional< ::Test::OneOptionalPrx> __ret;
        try
        {
            __ret = __proxy->end_opOneOptionalProxy(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opOneOptionalProxyPtr
newCallback_Initial_opOneOptionalProxy(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::OneOptionalPrx>&, const IceUtil::Optional< ::Test::OneOptionalPrx>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOneOptionalProxy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opOneOptionalProxyPtr
newCallback_Initial_opOneOptionalProxy(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::OneOptionalPrx>&, const IceUtil::Optional< ::Test::OneOptionalPrx>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOneOptionalProxy<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opOneOptionalProxy : public Callback_Initial_opOneOptionalProxy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::OneOptionalPrx>&, const IceUtil::Optional< ::Test::OneOptionalPrx>&, const CT&);

    Callback_Initial_opOneOptionalProxy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::OneOptionalPrx> p3;
        IceUtil::Optional< ::Test::OneOptionalPrx> __ret;
        try
        {
            __ret = __proxy->end_opOneOptionalProxy(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opOneOptionalProxyPtr
newCallback_Initial_opOneOptionalProxy(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::OneOptionalPrx>&, const IceUtil::Optional< ::Test::OneOptionalPrx>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOneOptionalProxy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opOneOptionalProxyPtr
newCallback_Initial_opOneOptionalProxy(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::OneOptionalPrx>&, const IceUtil::Optional< ::Test::OneOptionalPrx>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOneOptionalProxy<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opByteSeq : public Callback_Initial_opByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&);

    CallbackNC_Initial_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> > p3;
        IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> > __ret;
        try
        {
            __proxy->___end_opByteSeq(p3, __ret, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opByteSeqPtr
newCallback_Initial_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opByteSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opByteSeqPtr
newCallback_Initial_opByteSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opByteSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opByteSeq : public Callback_Initial_opByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const CT&);

    Callback_Initial_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> > p3;
        IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> > __ret;
        try
        {
            __proxy->___end_opByteSeq(p3, __ret, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opByteSeqPtr
newCallback_Initial_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opByteSeqPtr
newCallback_Initial_opByteSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opBoolSeq : public Callback_Initial_opBoolSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&);

    CallbackNC_Initial_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const bool*, const bool*> > p3;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > > ___p3;
        IceUtil::Optional< ::std::pair<const bool*, const bool*> > __ret;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > > _____ret;
        try
        {
            __proxy->___end_opBoolSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3 = ___p3->second;
            }
            if(_____ret)
            {
                __ret = _____ret->second;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opBoolSeqPtr
newCallback_Initial_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBoolSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opBoolSeqPtr
newCallback_Initial_opBoolSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBoolSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opBoolSeq : public Callback_Initial_opBoolSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const CT&);

    Callback_Initial_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const bool*, const bool*> > p3;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > > ___p3;
        IceUtil::Optional< ::std::pair<const bool*, const bool*> > __ret;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > > _____ret;
        try
        {
            __proxy->___end_opBoolSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3 = ___p3->second;
            }
            if(_____ret)
            {
                __ret = _____ret->second;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opBoolSeqPtr
newCallback_Initial_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opBoolSeqPtr
newCallback_Initial_opBoolSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const IceUtil::Optional< ::std::pair<const bool*, const bool*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opShortSeq : public Callback_Initial_opShortSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&);

    CallbackNC_Initial_opShortSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> > p3;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Short>, ::std::pair<const  ::Ice::Short*, const  ::Ice::Short*> > > ___p3;
        IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> > __ret;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Short>, ::std::pair<const  ::Ice::Short*, const  ::Ice::Short*> > > _____ret;
        try
        {
            __proxy->___end_opShortSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3 = ___p3->second;
            }
            if(_____ret)
            {
                __ret = _____ret->second;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opShortSeqPtr
newCallback_Initial_opShortSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opShortSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opShortSeqPtr
newCallback_Initial_opShortSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opShortSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opShortSeq : public Callback_Initial_opShortSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const CT&);

    Callback_Initial_opShortSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> > p3;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Short>, ::std::pair<const  ::Ice::Short*, const  ::Ice::Short*> > > ___p3;
        IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> > __ret;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Short>, ::std::pair<const  ::Ice::Short*, const  ::Ice::Short*> > > _____ret;
        try
        {
            __proxy->___end_opShortSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3 = ___p3->second;
            }
            if(_____ret)
            {
                __ret = _____ret->second;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opShortSeqPtr
newCallback_Initial_opShortSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opShortSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opShortSeqPtr
newCallback_Initial_opShortSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Short*, const ::Ice::Short*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opShortSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opIntSeq : public Callback_Initial_opIntSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&);

    CallbackNC_Initial_opIntSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> > p3;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Int>, ::std::pair<const  ::Ice::Int*, const  ::Ice::Int*> > > ___p3;
        IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> > __ret;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Int>, ::std::pair<const  ::Ice::Int*, const  ::Ice::Int*> > > _____ret;
        try
        {
            __proxy->___end_opIntSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3 = ___p3->second;
            }
            if(_____ret)
            {
                __ret = _____ret->second;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opIntSeqPtr
newCallback_Initial_opIntSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opIntSeqPtr
newCallback_Initial_opIntSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opIntSeq : public Callback_Initial_opIntSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const CT&);

    Callback_Initial_opIntSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> > p3;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Int>, ::std::pair<const  ::Ice::Int*, const  ::Ice::Int*> > > ___p3;
        IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> > __ret;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Int>, ::std::pair<const  ::Ice::Int*, const  ::Ice::Int*> > > _____ret;
        try
        {
            __proxy->___end_opIntSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3 = ___p3->second;
            }
            if(_____ret)
            {
                __ret = _____ret->second;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opIntSeqPtr
newCallback_Initial_opIntSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opIntSeqPtr
newCallback_Initial_opIntSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Int*, const ::Ice::Int*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opLongSeq : public Callback_Initial_opLongSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&);

    CallbackNC_Initial_opLongSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> > p3;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Long>, ::std::pair<const  ::Ice::Long*, const  ::Ice::Long*> > > ___p3;
        IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> > __ret;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Long>, ::std::pair<const  ::Ice::Long*, const  ::Ice::Long*> > > _____ret;
        try
        {
            __proxy->___end_opLongSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3 = ___p3->second;
            }
            if(_____ret)
            {
                __ret = _____ret->second;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opLongSeqPtr
newCallback_Initial_opLongSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opLongSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opLongSeqPtr
newCallback_Initial_opLongSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opLongSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opLongSeq : public Callback_Initial_opLongSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const CT&);

    Callback_Initial_opLongSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> > p3;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Long>, ::std::pair<const  ::Ice::Long*, const  ::Ice::Long*> > > ___p3;
        IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> > __ret;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Long>, ::std::pair<const  ::Ice::Long*, const  ::Ice::Long*> > > _____ret;
        try
        {
            __proxy->___end_opLongSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3 = ___p3->second;
            }
            if(_____ret)
            {
                __ret = _____ret->second;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opLongSeqPtr
newCallback_Initial_opLongSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opLongSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opLongSeqPtr
newCallback_Initial_opLongSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Long*, const ::Ice::Long*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opLongSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opFloatSeq : public Callback_Initial_opFloatSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&);

    CallbackNC_Initial_opFloatSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> > p3;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Float>, ::std::pair<const  ::Ice::Float*, const  ::Ice::Float*> > > ___p3;
        IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> > __ret;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Float>, ::std::pair<const  ::Ice::Float*, const  ::Ice::Float*> > > _____ret;
        try
        {
            __proxy->___end_opFloatSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3 = ___p3->second;
            }
            if(_____ret)
            {
                __ret = _____ret->second;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opFloatSeqPtr
newCallback_Initial_opFloatSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFloatSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opFloatSeqPtr
newCallback_Initial_opFloatSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFloatSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opFloatSeq : public Callback_Initial_opFloatSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const CT&);

    Callback_Initial_opFloatSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> > p3;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Float>, ::std::pair<const  ::Ice::Float*, const  ::Ice::Float*> > > ___p3;
        IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> > __ret;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Float>, ::std::pair<const  ::Ice::Float*, const  ::Ice::Float*> > > _____ret;
        try
        {
            __proxy->___end_opFloatSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3 = ___p3->second;
            }
            if(_____ret)
            {
                __ret = _____ret->second;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opFloatSeqPtr
newCallback_Initial_opFloatSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFloatSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opFloatSeqPtr
newCallback_Initial_opFloatSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Float*, const ::Ice::Float*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFloatSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opDoubleSeq : public Callback_Initial_opDoubleSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&);

    CallbackNC_Initial_opDoubleSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> > p3;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > > ___p3;
        IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> > __ret;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > > _____ret;
        try
        {
            __proxy->___end_opDoubleSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3 = ___p3->second;
            }
            if(_____ret)
            {
                __ret = _____ret->second;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opDoubleSeqPtr
newCallback_Initial_opDoubleSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDoubleSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opDoubleSeqPtr
newCallback_Initial_opDoubleSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDoubleSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opDoubleSeq : public Callback_Initial_opDoubleSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const CT&);

    Callback_Initial_opDoubleSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> > p3;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > > ___p3;
        IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> > __ret;
        IceUtil::Optional< ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > > _____ret;
        try
        {
            __proxy->___end_opDoubleSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3 = ___p3->second;
            }
            if(_____ret)
            {
                __ret = _____ret->second;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opDoubleSeqPtr
newCallback_Initial_opDoubleSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDoubleSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opDoubleSeqPtr
newCallback_Initial_opDoubleSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const IceUtil::Optional< ::std::pair<const ::Ice::Double*, const ::Ice::Double*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDoubleSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opStringSeq : public Callback_Initial_opStringSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&);

    CallbackNC_Initial_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> > p3;
        IceUtil::Optional< ::Test::StringSeq> ___p3;
        IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> > __ret;
        IceUtil::Optional< ::Test::StringSeq> _____ret;
        try
        {
            _____ret = __proxy->end_opStringSeq(___p3, __result);
            if(___p3)
            {
                p3.__setIsSet();
                p3->first = (*___p3).begin();
                p3->second = (*___p3).end();
            }
            if(_____ret)
            {
                __ret.__setIsSet();
                __ret->first = (*_____ret).begin();
                __ret->second = (*_____ret).end();
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opStringSeqPtr
newCallback_Initial_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opStringSeqPtr
newCallback_Initial_opStringSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opStringSeq : public Callback_Initial_opStringSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const CT&);

    Callback_Initial_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> > p3;
        IceUtil::Optional< ::Test::StringSeq> ___p3;
        IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> > __ret;
        IceUtil::Optional< ::Test::StringSeq> _____ret;
        try
        {
            _____ret = __proxy->end_opStringSeq(___p3, __result);
            if(___p3)
            {
                p3.__setIsSet();
                p3->first = (*___p3).begin();
                p3->second = (*___p3).end();
            }
            if(_____ret)
            {
                __ret.__setIsSet();
                __ret->first = (*_____ret).begin();
                __ret->second = (*_____ret).end();
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opStringSeqPtr
newCallback_Initial_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opStringSeqPtr
newCallback_Initial_opStringSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::StringSeq::const_iterator,  ::Test::StringSeq::const_iterator> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opSmallStructSeq : public Callback_Initial_opSmallStructSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&);

    CallbackNC_Initial_opSmallStructSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> > p3;
        IceUtil::Optional< ::std::vector< ::Test::SmallStruct> > ___p3;
        IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> > __ret;
        IceUtil::Optional< ::std::vector< ::Test::SmallStruct> > _____ret;
        try
        {
            __proxy->___end_opSmallStructSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3.__setIsSet();
                if(!___p3->empty())
                {
                    p3->first = &(*___p3)[0];
                    p3->second = p3->first + ___p3->size();
                }
                else
                {
                    p3->first = p3->second = 0;
                }
            }
            if(_____ret)
            {
                __ret.__setIsSet();
                if(!_____ret->empty())
                {
                    __ret->first = &(*_____ret)[0];
                    __ret->second = __ret->first + _____ret->size();
                }
                else
                {
                    __ret->first = __ret->second = 0;
                }
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opSmallStructSeqPtr
newCallback_Initial_opSmallStructSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opSmallStructSeqPtr
newCallback_Initial_opSmallStructSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opSmallStructSeq : public Callback_Initial_opSmallStructSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const CT&);

    Callback_Initial_opSmallStructSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> > p3;
        IceUtil::Optional< ::std::vector< ::Test::SmallStruct> > ___p3;
        IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> > __ret;
        IceUtil::Optional< ::std::vector< ::Test::SmallStruct> > _____ret;
        try
        {
            __proxy->___end_opSmallStructSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3.__setIsSet();
                if(!___p3->empty())
                {
                    p3->first = &(*___p3)[0];
                    p3->second = p3->first + ___p3->size();
                }
                else
                {
                    p3->first = p3->second = 0;
                }
            }
            if(_____ret)
            {
                __ret.__setIsSet();
                if(!_____ret->empty())
                {
                    __ret->first = &(*_____ret)[0];
                    __ret->second = __ret->first + _____ret->size();
                }
                else
                {
                    __ret->first = __ret->second = 0;
                }
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opSmallStructSeqPtr
newCallback_Initial_opSmallStructSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opSmallStructSeqPtr
newCallback_Initial_opSmallStructSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opSmallStructList : public Callback_Initial_opSmallStructList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&);

    CallbackNC_Initial_opSmallStructList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> > p3;
        IceUtil::Optional< ::std::vector< ::Test::SmallStruct> > ___p3;
        IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> > __ret;
        IceUtil::Optional< ::std::vector< ::Test::SmallStruct> > _____ret;
        try
        {
            __proxy->___end_opSmallStructList(___p3, _____ret, __result);
            if(___p3)
            {
                p3.__setIsSet();
                if(!___p3->empty())
                {
                    p3->first = &(*___p3)[0];
                    p3->second = p3->first + ___p3->size();
                }
                else
                {
                    p3->first = p3->second = 0;
                }
            }
            if(_____ret)
            {
                __ret.__setIsSet();
                if(!_____ret->empty())
                {
                    __ret->first = &(*_____ret)[0];
                    __ret->second = __ret->first + _____ret->size();
                }
                else
                {
                    __ret->first = __ret->second = 0;
                }
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opSmallStructListPtr
newCallback_Initial_opSmallStructList(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opSmallStructListPtr
newCallback_Initial_opSmallStructList(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opSmallStructList : public Callback_Initial_opSmallStructList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const CT&);

    Callback_Initial_opSmallStructList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> > p3;
        IceUtil::Optional< ::std::vector< ::Test::SmallStruct> > ___p3;
        IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> > __ret;
        IceUtil::Optional< ::std::vector< ::Test::SmallStruct> > _____ret;
        try
        {
            __proxy->___end_opSmallStructList(___p3, _____ret, __result);
            if(___p3)
            {
                p3.__setIsSet();
                if(!___p3->empty())
                {
                    p3->first = &(*___p3)[0];
                    p3->second = p3->first + ___p3->size();
                }
                else
                {
                    p3->first = p3->second = 0;
                }
            }
            if(_____ret)
            {
                __ret.__setIsSet();
                if(!_____ret->empty())
                {
                    __ret->first = &(*_____ret)[0];
                    __ret->second = __ret->first + _____ret->size();
                }
                else
                {
                    __ret->first = __ret->second = 0;
                }
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opSmallStructListPtr
newCallback_Initial_opSmallStructList(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opSmallStructListPtr
newCallback_Initial_opSmallStructList(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opFixedStructSeq : public Callback_Initial_opFixedStructSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&);

    CallbackNC_Initial_opFixedStructSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> > p3;
        IceUtil::Optional< ::std::vector< ::Test::FixedStruct> > ___p3;
        IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> > __ret;
        IceUtil::Optional< ::std::vector< ::Test::FixedStruct> > _____ret;
        try
        {
            __proxy->___end_opFixedStructSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3.__setIsSet();
                if(!___p3->empty())
                {
                    p3->first = &(*___p3)[0];
                    p3->second = p3->first + ___p3->size();
                }
                else
                {
                    p3->first = p3->second = 0;
                }
            }
            if(_____ret)
            {
                __ret.__setIsSet();
                if(!_____ret->empty())
                {
                    __ret->first = &(*_____ret)[0];
                    __ret->second = __ret->first + _____ret->size();
                }
                else
                {
                    __ret->first = __ret->second = 0;
                }
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opFixedStructSeqPtr
newCallback_Initial_opFixedStructSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opFixedStructSeqPtr
newCallback_Initial_opFixedStructSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opFixedStructSeq : public Callback_Initial_opFixedStructSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const CT&);

    Callback_Initial_opFixedStructSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> > p3;
        IceUtil::Optional< ::std::vector< ::Test::FixedStruct> > ___p3;
        IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> > __ret;
        IceUtil::Optional< ::std::vector< ::Test::FixedStruct> > _____ret;
        try
        {
            __proxy->___end_opFixedStructSeq(___p3, _____ret, __result);
            if(___p3)
            {
                p3.__setIsSet();
                if(!___p3->empty())
                {
                    p3->first = &(*___p3)[0];
                    p3->second = p3->first + ___p3->size();
                }
                else
                {
                    p3->first = p3->second = 0;
                }
            }
            if(_____ret)
            {
                __ret.__setIsSet();
                if(!_____ret->empty())
                {
                    __ret->first = &(*_____ret)[0];
                    __ret->second = __ret->first + _____ret->size();
                }
                else
                {
                    __ret->first = __ret->second = 0;
                }
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opFixedStructSeqPtr
newCallback_Initial_opFixedStructSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opFixedStructSeqPtr
newCallback_Initial_opFixedStructSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opFixedStructList : public Callback_Initial_opFixedStructList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&);

    CallbackNC_Initial_opFixedStructList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> > p3;
        IceUtil::Optional< ::std::vector< ::Test::FixedStruct> > ___p3;
        IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> > __ret;
        IceUtil::Optional< ::std::vector< ::Test::FixedStruct> > _____ret;
        try
        {
            __proxy->___end_opFixedStructList(___p3, _____ret, __result);
            if(___p3)
            {
                p3.__setIsSet();
                if(!___p3->empty())
                {
                    p3->first = &(*___p3)[0];
                    p3->second = p3->first + ___p3->size();
                }
                else
                {
                    p3->first = p3->second = 0;
                }
            }
            if(_____ret)
            {
                __ret.__setIsSet();
                if(!_____ret->empty())
                {
                    __ret->first = &(*_____ret)[0];
                    __ret->second = __ret->first + _____ret->size();
                }
                else
                {
                    __ret->first = __ret->second = 0;
                }
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opFixedStructListPtr
newCallback_Initial_opFixedStructList(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opFixedStructListPtr
newCallback_Initial_opFixedStructList(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opFixedStructList : public Callback_Initial_opFixedStructList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const CT&);

    Callback_Initial_opFixedStructList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> > p3;
        IceUtil::Optional< ::std::vector< ::Test::FixedStruct> > ___p3;
        IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> > __ret;
        IceUtil::Optional< ::std::vector< ::Test::FixedStruct> > _____ret;
        try
        {
            __proxy->___end_opFixedStructList(___p3, _____ret, __result);
            if(___p3)
            {
                p3.__setIsSet();
                if(!___p3->empty())
                {
                    p3->first = &(*___p3)[0];
                    p3->second = p3->first + ___p3->size();
                }
                else
                {
                    p3->first = p3->second = 0;
                }
            }
            if(_____ret)
            {
                __ret.__setIsSet();
                if(!_____ret->empty())
                {
                    __ret->first = &(*_____ret)[0];
                    __ret->second = __ret->first + _____ret->size();
                }
                else
                {
                    __ret->first = __ret->second = 0;
                }
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opFixedStructListPtr
newCallback_Initial_opFixedStructList(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opFixedStructListPtr
newCallback_Initial_opFixedStructList(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const IceUtil::Optional< ::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opVarStructSeq : public Callback_Initial_opVarStructSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&);

    CallbackNC_Initial_opVarStructSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> > p3;
        IceUtil::Optional< ::Test::VarStructSeq> ___p3;
        IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> > __ret;
        IceUtil::Optional< ::Test::VarStructSeq> _____ret;
        try
        {
            _____ret = __proxy->end_opVarStructSeq(___p3, __result);
            if(___p3)
            {
                p3.__setIsSet();
                p3->first = (*___p3).begin();
                p3->second = (*___p3).end();
            }
            if(_____ret)
            {
                __ret.__setIsSet();
                __ret->first = (*_____ret).begin();
                __ret->second = (*_____ret).end();
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opVarStructSeqPtr
newCallback_Initial_opVarStructSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVarStructSeq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opVarStructSeqPtr
newCallback_Initial_opVarStructSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVarStructSeq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opVarStructSeq : public Callback_Initial_opVarStructSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const CT&);

    Callback_Initial_opVarStructSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> > p3;
        IceUtil::Optional< ::Test::VarStructSeq> ___p3;
        IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> > __ret;
        IceUtil::Optional< ::Test::VarStructSeq> _____ret;
        try
        {
            _____ret = __proxy->end_opVarStructSeq(___p3, __result);
            if(___p3)
            {
                p3.__setIsSet();
                p3->first = (*___p3).begin();
                p3->second = (*___p3).end();
            }
            if(_____ret)
            {
                __ret.__setIsSet();
                __ret->first = (*_____ret).begin();
                __ret->second = (*_____ret).end();
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opVarStructSeqPtr
newCallback_Initial_opVarStructSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVarStructSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opVarStructSeqPtr
newCallback_Initial_opVarStructSeq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const IceUtil::Optional< ::std::pair< ::Test::VarStructSeq::const_iterator,  ::Test::VarStructSeq::const_iterator> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVarStructSeq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opSerializable : public Callback_Initial_opSerializable_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::Serializable>&, const IceUtil::Optional< ::Test::Serializable>&);

    CallbackNC_Initial_opSerializable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::Serializable> p3;
        IceUtil::Optional< ::Test::Serializable> __ret;
        try
        {
            __ret = __proxy->end_opSerializable(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opSerializablePtr
newCallback_Initial_opSerializable(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::Serializable>&, const IceUtil::Optional< ::Test::Serializable>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSerializable<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opSerializablePtr
newCallback_Initial_opSerializable(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::Serializable>&, const IceUtil::Optional< ::Test::Serializable>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSerializable<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opSerializable : public Callback_Initial_opSerializable_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::Serializable>&, const IceUtil::Optional< ::Test::Serializable>&, const CT&);

    Callback_Initial_opSerializable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::Serializable> p3;
        IceUtil::Optional< ::Test::Serializable> __ret;
        try
        {
            __ret = __proxy->end_opSerializable(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opSerializablePtr
newCallback_Initial_opSerializable(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::Serializable>&, const IceUtil::Optional< ::Test::Serializable>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSerializable<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opSerializablePtr
newCallback_Initial_opSerializable(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::Serializable>&, const IceUtil::Optional< ::Test::Serializable>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSerializable<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opIntIntDict : public Callback_Initial_opIntIntDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::IntIntDict>&, const IceUtil::Optional< ::Test::IntIntDict>&);

    CallbackNC_Initial_opIntIntDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::IntIntDict> p3;
        IceUtil::Optional< ::Test::IntIntDict> __ret;
        try
        {
            __ret = __proxy->end_opIntIntDict(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opIntIntDictPtr
newCallback_Initial_opIntIntDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::IntIntDict>&, const IceUtil::Optional< ::Test::IntIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntIntDict<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opIntIntDictPtr
newCallback_Initial_opIntIntDict(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::IntIntDict>&, const IceUtil::Optional< ::Test::IntIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntIntDict<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opIntIntDict : public Callback_Initial_opIntIntDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::IntIntDict>&, const IceUtil::Optional< ::Test::IntIntDict>&, const CT&);

    Callback_Initial_opIntIntDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::IntIntDict> p3;
        IceUtil::Optional< ::Test::IntIntDict> __ret;
        try
        {
            __ret = __proxy->end_opIntIntDict(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opIntIntDictPtr
newCallback_Initial_opIntIntDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::IntIntDict>&, const IceUtil::Optional< ::Test::IntIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntIntDict<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opIntIntDictPtr
newCallback_Initial_opIntIntDict(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::IntIntDict>&, const IceUtil::Optional< ::Test::IntIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntIntDict<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opStringIntDict : public Callback_Initial_opStringIntDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&);

    CallbackNC_Initial_opStringIntDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::StringIntDict> p3;
        IceUtil::Optional< ::Test::StringIntDict> __ret;
        try
        {
            __ret = __proxy->end_opStringIntDict(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opStringIntDictPtr
newCallback_Initial_opStringIntDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringIntDict<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opStringIntDictPtr
newCallback_Initial_opStringIntDict(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringIntDict<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opStringIntDict : public Callback_Initial_opStringIntDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&, const CT&);

    Callback_Initial_opStringIntDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::StringIntDict> p3;
        IceUtil::Optional< ::Test::StringIntDict> __ret;
        try
        {
            __ret = __proxy->end_opStringIntDict(p3, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opStringIntDictPtr
newCallback_Initial_opStringIntDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringIntDict<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opStringIntDictPtr
newCallback_Initial_opStringIntDict(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringIntDict<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opCustomIntStringDict : public Callback_Initial_opCustomIntStringDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&);

    CallbackNC_Initial_opCustomIntStringDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> > p3;
        IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> > __ret;
        try
        {
            __proxy->___end_opCustomIntStringDict(p3, __ret, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, p3);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_opCustomIntStringDictPtr
newCallback_Initial_opCustomIntStringDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opCustomIntStringDict<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opCustomIntStringDictPtr
newCallback_Initial_opCustomIntStringDict(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opCustomIntStringDict<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opCustomIntStringDict : public Callback_Initial_opCustomIntStringDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const CT&);

    Callback_Initial_opCustomIntStringDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> > p3;
        IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> > __ret;
        try
        {
            __proxy->___end_opCustomIntStringDict(p3, __ret, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, p3, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_opCustomIntStringDictPtr
newCallback_Initial_opCustomIntStringDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opCustomIntStringDict<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opCustomIntStringDictPtr
newCallback_Initial_opCustomIntStringDict(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const IceUtil::Optional< ::std::map< ::Ice::Int, ::Util::string_view> >&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opCustomIntStringDict<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_opClassAndUnknownOptional : public Callback_Initial_opClassAndUnknownOptional_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_opClassAndUnknownOptional(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opClassAndUnknownOptional<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opClassAndUnknownOptional<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opClassAndUnknownOptional<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opClassAndUnknownOptional<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_opClassAndUnknownOptional : public Callback_Initial_opClassAndUnknownOptional_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_opClassAndUnknownOptional(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opClassAndUnknownOptional<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opClassAndUnknownOptional<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opClassAndUnknownOptional<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opClassAndUnknownOptional<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_sendOptionalClass : public Callback_Initial_sendOptionalClass_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_sendOptionalClass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_sendOptionalClass<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_sendOptionalClass<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_sendOptionalClass<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_sendOptionalClass<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_sendOptionalClass : public Callback_Initial_sendOptionalClass_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_sendOptionalClass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_sendOptionalClass<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_sendOptionalClass<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_sendOptionalClass<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_sendOptionalClass<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_returnOptionalClass : public Callback_Initial_returnOptionalClass_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::OneOptionalPtr>&);

    CallbackNC_Initial_returnOptionalClass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::OneOptionalPtr> o;
        try
        {
            __proxy->end_returnOptionalClass(o, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(o);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_returnOptionalClassPtr
newCallback_Initial_returnOptionalClass(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::OneOptionalPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_returnOptionalClass<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_returnOptionalClassPtr
newCallback_Initial_returnOptionalClass(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::OneOptionalPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_returnOptionalClass<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_returnOptionalClass : public Callback_Initial_returnOptionalClass_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const CT&);

    Callback_Initial_returnOptionalClass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        IceUtil::Optional< ::Test::OneOptionalPtr> o;
        try
        {
            __proxy->end_returnOptionalClass(o, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(o, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_returnOptionalClassPtr
newCallback_Initial_returnOptionalClass(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_returnOptionalClass<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_returnOptionalClassPtr
newCallback_Initial_returnOptionalClass(T* instance, void (T::*cb)(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_returnOptionalClass<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_supportsRequiredParams : public Callback_Initial_supportsRequiredParams_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Initial_supportsRequiredParams(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_supportsRequiredParams(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_supportsRequiredParamsPtr
newCallback_Initial_supportsRequiredParams(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsRequiredParams<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_supportsRequiredParamsPtr
newCallback_Initial_supportsRequiredParams(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsRequiredParams<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_supportsRequiredParams : public Callback_Initial_supportsRequiredParams_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Initial_supportsRequiredParams(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_supportsRequiredParams(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_supportsRequiredParamsPtr
newCallback_Initial_supportsRequiredParams(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsRequiredParams<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_supportsRequiredParamsPtr
newCallback_Initial_supportsRequiredParams(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsRequiredParams<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_supportsJavaSerializable : public Callback_Initial_supportsJavaSerializable_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Initial_supportsJavaSerializable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_supportsJavaSerializable(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_supportsJavaSerializablePtr
newCallback_Initial_supportsJavaSerializable(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsJavaSerializable<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_supportsJavaSerializablePtr
newCallback_Initial_supportsJavaSerializable(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsJavaSerializable<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_supportsJavaSerializable : public Callback_Initial_supportsJavaSerializable_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Initial_supportsJavaSerializable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_supportsJavaSerializable(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_supportsJavaSerializablePtr
newCallback_Initial_supportsJavaSerializable(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsJavaSerializable<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_supportsJavaSerializablePtr
newCallback_Initial_supportsJavaSerializable(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsJavaSerializable<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_supportsCsharpSerializable : public Callback_Initial_supportsCsharpSerializable_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Initial_supportsCsharpSerializable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_supportsCsharpSerializable(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_supportsCsharpSerializablePtr
newCallback_Initial_supportsCsharpSerializable(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsCsharpSerializable<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_supportsCsharpSerializablePtr
newCallback_Initial_supportsCsharpSerializable(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsCsharpSerializable<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_supportsCsharpSerializable : public Callback_Initial_supportsCsharpSerializable_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Initial_supportsCsharpSerializable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_supportsCsharpSerializable(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_supportsCsharpSerializablePtr
newCallback_Initial_supportsCsharpSerializable(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsCsharpSerializable<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_supportsCsharpSerializablePtr
newCallback_Initial_supportsCsharpSerializable(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsCsharpSerializable<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Initial_supportsCppStringView : public Callback_Initial_supportsCppStringView_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Initial_supportsCppStringView(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_supportsCppStringView(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Initial_supportsCppStringViewPtr
newCallback_Initial_supportsCppStringView(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsCppStringView<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Initial_supportsCppStringViewPtr
newCallback_Initial_supportsCppStringView(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsCppStringView<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Initial_supportsCppStringView : public Callback_Initial_supportsCppStringView_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Initial_supportsCppStringView(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Test::InitialPrx __proxy = ::Test::InitialPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_supportsCppStringView(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Initial_supportsCppStringViewPtr
newCallback_Initial_supportsCppStringView(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsCppStringView<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Initial_supportsCppStringViewPtr
newCallback_Initial_supportsCppStringView(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsCppStringView<T, CT>(instance, cb, excb, sentcb);
}

}

#endif
