Changes since version 2.1.0
---------------------------

- Fixed a race condition that could cause a process to abort
  during shutdown.

- Added sequences of fixed-length elements to throughput demo.

- Fixed a bug that could cause an assert if connections could not be
  established in thread-per-connection mode.

- Added two new properties for controlling Active Connection
  Management (ACM). In prior releases ACM was governed by the property
  Ice.ConnectionIdleTime, which affected client- and server-side
  behavior. The new properties, Ice.ACM.Client and Ice.ACM.Server,
  now allow independent timeouts to be specified for client- and
  server-side ACM. Ice.ConnectionIdleTime is now deprecated.

- Reverted a change introduced in 2.1.0 in which retries were not
  attempted for oneway and batch oneway requests. Ice now behaves
  as it did in prior releases: if the connection associated with a
  oneway or batch oneway proxy is closed, an invocation on the proxy
  will transparently reestablish the connection. Please see the Ice
  manual for more information on the reliability of oneway and batch
  oneway reliability.

- Ice::ObjectNotExistException is now retried for invocations made on
  indirect proxies. This allows the transparent migration of objects
  or objects adapters.

- Changed the IceBox.ServiceManagerI class to be inheritable and its
  run() method to be public.

- Fixed a bug in the option parsing for Ice tools such as slice2cpp,
  slice2java, slice2cs, etc. The option parser used to incorrectly
  complain about repeated options when in fact no option was repeated.
  Also changed the parser to permit options to follow an argument, so

      slice2cpp -I. x.ice

  and

      slice2cpp x.ice -I.

  are now equivalent.

- Added -E option to the various Slice compilers to print preprocessor
  output on stdout.

- As announced with version 1.5, slice2java and slice2freezej now
  require all Slice definitions to be nested inside a module;
  definitions at global scope (other than module definitions) now
  cause a hard error (whereas, previously, they only caused a
  warning).

Changes since version 2.0.0
---------------------------

- The Java build system now requires Apache ant version 1.6.2 or greater.

- We do not retry oneway or batch oneway requests anymore, except if
  there are problems during connection establishment. If we retry a
  oneway or batch oneway, previous oneways from the same batch, or
  previous oneways that are buffered by the IP stack implementation,
  are silently thrown away. This can lead to a situation where the
  latest oneway succeeds due to retry, but former oneways are
  discarded.

- Fixed race between connection validation and activation for UDP
  endpoints in thread-per-connection mode.

- Fixed a deadlock that could occur if a server cannot send data
  during connection validation.

- Metadata is now allowed for dictionary types.

- Added support for SSL. The Java plug-in uses the SSL capabilities
  provided by Java 1.4.2. As such, the plug-in is not compatible with
  the Ice thread pool, therefore the property Ice.ThreadPerConnection=1
  must be defined for any communicator in which the plug-in is
  installed. See the Ice manual for more information.

- Added an optimization to the Freeze evictor for the ice_ping
  operation. The object is no longer loaded into the cache by this
  operation; Freeze simply checks if the object is in the cache or
  the database.

- Added setDefaultContext() and getDefaultContext() to the
  Ice.Communicator interface. This allows a default context to be
  established on a communicator-wide basis. See section 29.9.3 in
  the doc.

  Added ice_defaultContext to Ice.ObjectPrx. This creates a new
  proxy that uses the default context established on the communicator.

- Overloaded the checkedCast member function of the generated proxy
  helper classes to allow a trailing argument of type Ice::Context.
  This makes it possible to do stateful things that require a context
  in a servant locator's activate() method.

- Added support for bzip2 protocol compression. The implementation
  uses the bzip2 classes from Ant. See the INSTALL file for more
  information.

Changes since version 1.5.1
---------------------------

- The proxy returned by the object adapter operations addFacet and
  addFacetWithUUID did not contain the facet. This required the
  application to make an extra call to ice_newFacet in order to
  obtain the correct proxy. This has been fixed.

- Added the object adapter property <name>.PublishedEndpoints, which
  specifies endpoints to advertise in proxies created by the adapter.

- Fixed a bug with AMD exception handling, where it was possible that
  certain exceptions propagate out of ice_response() or
  ice_exception(), and therefore such exceptions were not handled
  properly.

- Exceptions raised while marshaling data for batch requests resulted
  in a connection deadlock. This has been fixed.

- Fixed tracing of operation mode.

- Fixed a bug that caused marshaling failures when global metadata was
  used to define an alternate Java package. Two new properties are
  supported: Ice.Package.* and Ice.Default.Package. See the manual for
  more information.

- Fixed bug in slice2java: with the --impl-tie option, incorrect code
  was generated for local interfaces and classes.

- Changed code generation in slice2java: for local interfaces, only an
  OperationsNC (but no Operations) interface is generated
  now. (Previously, both interfaces were generated, with one of them
  being empty.)

- Freeze dictionaries now support indices. You can index on the full
  value of the dictionary, or on a member (when the value is a struct
  or a class). When you index on a member, you can define several
  indices (for different members). See the Freeze bench demo and the
  Freeze dbmap test for examples.

- Fixed the slice2java compiler for operations with multiple
  exceptions in an exception specification: if an exception was a base
  of one or more other exceptions in the same exception specification,
  the code generator sometimes emitted the catch blocks in the
  marshaling and dispatch code in the wrong order. (This applied only
  to interfaces with an ["amd"] metadata directive.)

- The documentation has always stated that same-named constructs
  cannot be directly nested inside each other. (For example, a module
  `M' cannot contain a constant named `M'. The slice2java compiler did
  not enforce this correctly up to now for modules containing
  constructs with the same name as the enclosing module.  This has
  been fixed and now results in a diagnostic.

- The slice2java compiler now deprecates Slice definitions at global
  scope: only modules can be defined at global scope. Everything else
  (constants, classes, interfaces, etc.) must be defined inside a
  module.

  For the time being, the compiler issues a warning for each global
  definition but continues to compile the code. Global non-module
  definitions will elicit a hard error two releases from now.

- Several demos used Slice classes where interface were more
  appropriate. This has been fixed.

- Ice.Util.initializeWithProperties() now correctly parses the command
  line arguments.

- Fixed a bug in slice2java that caused byte constants to be
  initialized incorrectly.

- For classes with operations, the code generator now generates
  overloaded methods for each operation, one exactly as before, and
  another one without the trailing Ice.Current parameter.  For
  example:

  // Slice
  class Foo
  {
      void op();
  };

  // Java
  public abstract class Foo extends Ice.ObjectImpl
                            implements _FooOperations, _FooOperationsNC
  {
      public final void
      op()
      {
          op(null);
      }
  }

  public interface _FooOperations
  {
      void op(Ice.Current __current);
  }

  public interface _FooOperationsNC
  {
      void op();
  }

  This change allows you to call an operation on a class without
  having to supply a null dummy argument:

  Foo f = new FooI();
  f.op(null);		// Previously, null had to be passed. This still works.
  f.op();		// OK as of now.

- New properties Ice.StdErr and Ice.StdOut to redirect the standard
  error and output streams of a process.

Changes since version 1.5.0
---------------------------

- No changes between 1.5.0 and 1.5.1.

Changes since version 1.4.0
---------------------------

- Added support for generating checksums of Slice definitions,
  enabling peers to verify that they share the same client-server
  contract. See the manual for more information.

- Fixed a bug that could cause an assert or exception in some rare
  circumstances, if an operation is invoked after the object adapter
  for the Ice object has been deactivated.

- Fixed a bug that could cause a NullPointerException while
  unmarshaling a sequence of objects containing a null element.

- Changed the mapping for tie classes, which now implement the
  interface Ice.TieBase. This interface defines the ice_delegate
  methods and changes the delegate type from _FooOperations to
  java.lang.Object.

- Changed the --depend option of slice2java. If you get dependencies
  for a file x.ice that includes y.ice, the dependency line that is
  written now is "/path/x.ice: /path/y.ice". (Previously, it was
  "x.cpp: /path/x.ice /path/y.ice".) With some post-processing, this is
  sufficient to generate dependencies for tools such as ant and make.

Changes since version 1.3.0
---------------------------

- Fixed a bug when making asynchronous invocations on a routed proxy.

- Changed the way sequences are unmarshaled to protect against
  malicious messages with faked very large sequence count values.
  While even with previous versions of Ice, buffer overruns were
  impossible, malicious messages could cause large amounts of memory
  to be preallocated, causing the receiving process to run out of
  memory. This is no longer possible -- the total amount of memory
  preallocated for sequences during unmarshaling is now capped at
  Ice.MessageSizeMax.

- Removed a bogus assert that could happen under certain race
  conditions when a connection timeout occurs.

- Added checkedCast and uncheckedCast operations to ObjectPrxHelper.

- Assertions in servant methods are now correctly caught and an error
  message is printed using the logger.

- Facets have been significantly redesigned.

  * Facets are no longer hierarchical. As a result, FacetPath (which
    was a sequence of strings) is now simply a string. This is
    reflected in all APIs that used FacetPath.

  * There is no longer an active facet map in Ice::Object. As a
    result, the following operations have been removed:

    + On proxies: ice_facets, ice_appendFacet.

    + On Object: ice_facets, ice_addFacet, ice_removeFacet,
      ice_updateFacet, ice_removeAllFacets, ice_findFacet,
      ice_findFacetPath.

  * The object adapter is now used to register facets instead of the
    active facet map. The following operations have been added to
    Ice::ObjectAdapter: addFacet, addFacetWithUUID, removeFacet,
    removeAllFacets, findFacet, and findAllFacets.

    Please see the reference manual for more information. For naming
    consistency, the following object adapter operations have been
    renamed:

    + identityToServant has been renamed to find.
    + proxyToServant has been renamed to findByProxy.

  * This object model design change means that facets are no longer
    transferred with an object sent by value.

  * If your application receives an object with facets from an older
    version of Ice, a MarshalException is raised. This is unavoidable
    because it is a change to the object model, and not just to the
    way objects are transferred or encoded.

  * If your application receives a request or reply with a facet path
    with more than one element, the run time throws a MarshalException.

  * If your application receives a proxy with a facet path with
    more than one element, the run time throws ProxyUnmarshalException.

- Ice no longer retries operation calls on RequestFailedException.
  (ObjectNotExistException, OperationNotExistException, and
  FacetNotExistException are derived from RequestFailedException.)

- Fixed a bug with certain cached objects not being destroyed when
  connections are closed.

- Added ConnectionRefusedException as a specialization of
  ConnectFailedException, to indicate if a connection fails because a
  server actively refuses the connection.

- Fixed the slice2java compiler for operations with multiple
  exceptions in an exception specification: if an exception was a base
  of one or more other exceptions in the same exception specification,
  the code generator sometimes emitted the catch blocks in the
  marshaling and dispatch code in the wrong order.

Changes since version 1.2.0
---------------------------

- Added Slice interface Ice::Process in slice/Ice/Process.ice. This
  interface enables IcePack to properly shut down a process without
  relying on signals, which is necessary for successful operation
  on Windows.

- Added setServerProcessProxy to Ice::LocatorRegistry.

- Added new properties <ObjectAdapter>.RegisterProcess and
  Ice.ServerId. If RegisterProcess is defined, the object adapter
  creates a servant implementing the Ice::Process interface and
  registers it with the locator registry using the server id
  defined by Ice.ServerId.

- Added the "register" attribute to the <adapter> element in the
  IcePack descriptors. If true, the RegisterProcess property is
  defined for the object adapter.

- Added getLocator to ObjectAdapter.

- Added the methods ice_preMarshal and ice_postUnmarshal to
  Ice.Object. The default implementations do nothing, but subclasses
  may override them to take special action before marshaling and
  after unmarshaling, respectively.

- Added the demo/IcePack/simple example.

- Connections are no longer closed when the last proxy using the
  connection is destroyed. Doing so is error prone:

  * Quite often, proxies are created on the fly, resulting in
    connections being opened and closed all the time. This is
    especially true for services that receive a proxy and data, and
    then forward this data using the proxy.

  * Often, connections are stay open for too long, because proxies are
    kept even though they are never used again.

  * It doesn't work well with AMI requests, because the AMI callback
    objects keep track of connections directly. This would mean that
    if a process only uses AMI requests, a connection is opened and
    closed for each request, as each request typically has its own
    AMI callback object.

  Instead, ACM (Automatic Connection Management) is now enabled by
  default, with a default value of one minute. This means that idle
  connections are closed after one minute, regardless of whether there
  are proxies using the connection or not. This closing of connections
  is transparent, i.e., closed connections are automatically
  reestablished in case they are needed again. Please see the
  description of the Ice.ConnectionIdleTime property for details.

- ACM has been completely reworked. It now works properly with respect
  to retrying failed requests.

- Added the IceBox.LoadOrder property, which specifies the order
  in which IceBox services are loaded.

- Added support for Berkeley DB 4.2.52.

- The default thread pool size is now just one thread. This is the
  fastest possible setting, still allows one level of nesting, and
  doesn't require that servants be thread safe. (Please see the
  description of the thread pool properties in the manual for
  information on how to increase the number of threads.)

- Fixed a problem with servers not shutting down properly under
  certain circumstances.

- Fixed a rare connection deadlock, that could happen if lots of long
  messages are sent rapidly in parallel, using separate threads or
  AMI.

- Ported demo/IcePack/hello from C++.

- Added new mechanism for generating Java code into packages.
  The global metadata prefix "java:package:" now specifies the
  package for all types in a Slice file. For example, the metadata
  [["java:package:com.zeroc"]] causes all of the classes to be
  generated in the com.zeroc package. The --package option is no
  longer supported by the translator, and the slice2java ant task
  has been changed accordingly.

- Changed the metadata prefix for specifying custom sequence types.
  The new prefix is "java:type:", to be consistent with the new
  package metadata described above. The old prefix "java:" is now
  deprecated.

- Added test/Ice/translator to exercise the translator's support
  for packages.

- Errors during close() or shutdown() on connections now cause
  exceptions.

- Fixed a deadlock that could happen if requests were sent from the
  exception() AMI callback.

- New Freeze.Warn.CloseInFinalize property. When this property is 
  set to a value greater than 0, a warning is issued when a live 
  iterator is closed by a finalizer. The default value is 1.
  To see this warning in programs that do not run very long or do 
  not create a large number of objects, it may be necessary
  to explicitly call the JVM garbage collector with System.gc().

- Added property Ice.Override.ConnectTimeout. See the manual for
  details.

- Fixed a rare deadlock in the object adapter, when a locator was
  used.

- A DNSException could cause a deadlock. This has been fixed.

- The Ice.Stats interface was not being invoked by the TCP and
  UDP transports. This has been fixed.

Changes since version 1.1.1
---------------------------

- Manual retry in the exception() callback of asynchronous requests
  didn't work. This has been fixed.

- Fixed a crash that could happen during shutdown.

- Fixed a deadlock that could happen during connection establishment.

- Fixed deadlock during shutdown that can happen if a thread pool with
  only one thread is used.

- Moved UserExceptionFactory from Ice package to IceInternal package
  because UserExceptionFactory is no longer an interface for use
  by applications.

- Bi-directional connections are now handled by the client-side thread
  pool instead of the server-side thread pool.

- Fixed a bug in the generated code that caused "at-most-once"
  semantics to be ignored for collocated invocations.

- Fixed ant tasks to use ICE_HOME (if defined) in the pathname of
  a translator executable.

- Implemented TwowayOnlyException. That exception is raised if an
  attempt is made to invoke an operation that has a return value,
  out parameters, or an exception specification via a oneway or
  datagram proxy.

- Removed ice_flush() on the proxy base class. Batch requests are
  now flushed by calling Communicator::flushBatchRequests(). This
  flushes all requests that are currently batched in the communicator,
  (for all connections).

- Added back the connection closure timeout, but only for misbehaving
  peers. If a timeout is set, and a peer doesn't react to a close
  connection message, the connection is forcefully closed after the
  timeout. However, it is never forcefully closed if requests are
  still outstanding. Doing so would violate ordering guarantees for
  finished() and deactivate() on servant locators.

- Fixed a bug in the slice2java code generator: if a parameter was
  named "current", illegal code was generated.

- Fixed a bug in the slice2java code generator: tie classes were not
  generated correctly for operations with an "amd" metadata directive.

- Fixed a bug where Ice would print a dispatch warning for
  Ice::RequestFailedException even if the Ice.Warn.Dispatch property
  was set to 1.

- Added per-proxy contexts. The change is source-code compatible with
  the previous approach, that is, it is still possible to pass an
  explicit Ice::Context to an operation call as an additional,
  trailing parameter. However, Ice.ObjectPrx now contains two
  new operations:

  - ice_getContext()

    This returns the context currently associated with a particular
    proxy. (By default, the context associated with proxies is empty.)

  - ice_newContext(java.util.Map context)

    This creates a new proxy that is associated with the passed
    context. Thereafter, calls via the new proxy always pass the
    context that was passed to ice_newContext() when that proxy was
    created.

  The net effect of this is that it is now possible to establish the
  context for a proxy once and, thereafter, have that same context
  sent automatically whenever an operation is invoked via the proxy
  (instead of having to pass an explicit context parameter on every
  call).

- Added Ice::Properties::parseIceCommandLineOptions(). This operation
  converts to properties all options that start with one of the
  following prefixes: --Ice, --IceBox, --IcePack, --IcePatch,
  --IceSSL, --IceStorm, --Freeze, and --Glacier.

- Added menu with several options to throughput demo.

- Major Freeze update. See corresponding entry in the Ice for C++
  CHANGES file.

- Added Ice.UDP.RcvSize and Ice.UDP.SndSize properties. These
  properties control the size of the UDP receive and send buffers as
  well as controlling the maximum size of a datagram invocation. If a
  datagram exceeds the configured size, the Ice run time throws a
  DatagramLimitException. (Note that, on the receiving size, detection
  of this condition is dependent on the local UDP implementation --
  some UDP implementations silently drop datagrams that are too large
  to fit into the receive buffer instead of reporting the error or
  delivering a truncated datagram.)

- Added Ice.Warn.Datagrams. This property prints a warning on the server
  side if a DatagramLimitException is thrown.

- Added Ice.MessageSizeMax property. This property controls the
  maximum message size accepted by the Ice protocol in kiloBytes. The
  default value is 1024 (1 MB).

- Fixed a number of incorrect property settings in the config files
  for the demos.

- Changed the return type of the ice_invoke_async method in
  Ice.BlobjectAsync to void instead of boolean.

- Added new property: Ice.Trace.Slicing. When set to a value > 0,
  unknown exception and class types that are sliced emit a warning.

- Added destroyOnInterrupt() to the Application
  class. destroyOnInterrupt() is now the default behavior, because
  shutdownOnInterrupt() only shuts down the server side of an
  application, and therefore doesn't work with pure clients.

- ObjectAdapter::removeServantLocator() no longer exists.  The life
  cycle of servant locators that are registered with an object adapter
  ends when the adapter is destroyed.

- Changed Ice::ServantLocator::deactivate to be passed the category
  for which a servant locator is being deactivated.

- Added saveObject() operation on Evictor, and savedObject() operation
  on PersistenceStrategy.

  saveObject() saves a persistent object immediately. Once an
  operation has called saveObject(), the object is considered "clean":
  other updates by the same operation can only be reliably saved by
  another call to saveObject().

- Added a test to the property parsing code to print a warning on
  System.err if a property is not recognized. This prevents silly
  typos, such as "Ice.config=MyFile" (instead of "Ice.Config=MyFile")
  from slipping through undetected.

- Changed the python code for printing output from test clients, so
  that you get each line as it comes.

Changes since version 1.1.0
---------------------------

- Added support for a default object factory, similar to the semantics
  of servant locators. Specifically, a factory registered with an
  empty type id is invoked when a type-specific factory cannot be
  found.

- Fixed a bug where the locator cache wasn't correctly updated upon a
  connection failure to a server. This was causing IceJ to try to
  re-establish the connection to the same server endpoints without
  asking the locator if eventually the endpoints had changed.

- Fixed server side bug with batch oneways or batch datagrams.

- Fixed a bug where the operation mode argument wasn't used in the
  implementation of the Ice.ObjectPrx ice_invoke method.

- Added missing declaration for ice_invoke_async to Ice.ObjectPrx.

- Fixed a bug in the generated code for custom sequences so that it
  now checks whether the sequence value is null.

- Added DB_PRIVATE flag to DBEnv->open(), to be able to use the
  Berkeley DB that ships with RedHat 9.

Changes since version 1.0.1
---------------------------

- Ice now implements slicing for exceptions and classes: if a process
  receives an exception or class that is of a more derived type than
  the receiver understands, the exception or class is automatically
  sliced. (Previously, this situation resulted in an exception.)

- User exception factories and user exception factory
  managers no longer exist. The factories for user exceptions
  are now automatically installed by the Ice run time.
  If you have existing code that implements user exception factories,
  you can simply delete it.

- Fixed a bug in the Slice parser: the semantic check to see
  whether an identifier introduced into a scope has changed
  meaning was too stringent.

- Fixed a bug with connections being closed even though they have
  outstanding batch requests.

- The "unknown" field in UnknownLocalException and UnknownException
  now contains the whole exception stack trace instead of just the
  exception name.

- Replaced the Freeze::EvictorPersistenceMode enumeration with the
  interface Freeze::PersistenceStrategy.

- Instead of aborting the caller thread, Ice for Java now catches
  assertions in servant methods, prints the assertion, closes the
  connection, and continues.

- Added dynamic thread pools, i.e., thread pools that grow and shrink
  based on a calculated load factor. Please see the section about thread
  pools in the manual for further details.

- Structs and sequences which hold other structs or sequences are now
  legal dictionary key types, as long as such nested structs or sequences
  are (recursively) legal.

- The connection timeout is now also used when connections are
  closed. This avoids hanging processes if the peer misbehaves, or if
  asynchronous method invocations do not return.

- In some cases, communicator destruction could result in a
  java.lang.NullPointerException. This has been fixed. Now a
  CommunicatorDestroyedException is raised.

- Fixed a bug with AMD methods using a servant locator, such as the
  Freeze evictor.

- Changed the generated equals() method to use the helper
  java.util.Arrays.equals() when comparing sequences, rather than the
  native array equals() method. This means the equals() method for a
  type containing a sequence member will perform a deep comparison of
  the sequence.

- Added timestamps to the default Ice logger. You can enable
  timestamps by setting the `Ice.Logger.Timestamp' property to a value
  larger than zero. By default timestamps are disabled.

- Improved IceBox service deactivation. Instead of successively
  stoping a service and destroying its communicator, services are now
  all stopped first and then their communicators are destroyed.

- Modified the Ice protocol to marshal sizes more efficiently.
  Sizes less than 255 now require a single byte whereas
  previously, sizes between 127 and 254 required five bytes.

- Modified the Ice protocol to fix a problem with compression. The
  compressed message types have been removed, and a field has been
  added to the message header indicating compression status.

- Added version negotiation to the Ice protocol. This permits future
  protocol extensions to be added without breaking interoperability
  with older deployed clients and servers. Unfortunately, doing this
  broke compatibility with the existing protocol so, when upgrading to
  this version, you must make sure that clients and servers use the
  same version of Ice.jar.

- Added a magic number to the Ice protocol. All Ice protocol messages
  have 'I', 'c', 'e', 'P' (encoded as ASCII) in the first four bytes.
  This is useful to allow protocol analyzers to recognize Ice
  messages.

- Changed the encoding of encapsulations. An encapsulation now looks
  like:

	size (4 bytes)
	major version number (1 byte)
	minor version number (1 byte)
	data (n bytes)

  The size includes the count of bytes for the size and versions, so
  the value of size is n + 6.

- Added -v and -e options to stringified UDP endpoints. -v sets the
  protocol version and -e sets the encoding version. (The current
  version for both protocol and encoding is 1.0.)

Changes since version 1.0.0
---------------------------

- Fixed a bug in the ObjectAdapter which caused it to ignore all but
  the first endpoint.

- Fixed a bug with throwing exceptions in AMD calls after invoking
  ice_response().

- Fixed a bug with throwing exceptions in AMI from within
  ice_response().


