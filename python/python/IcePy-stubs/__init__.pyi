from collections.abc import Awaitable, Callable
from typing import Any, Self, Type, TypeVar

import Ice

T = TypeVar("T", bound=Ice.ObjectPrx)

class AsyncInvocationContext:
    def cancel(self) -> None: ...

class BatchRequest:
    def enqueue(self) -> None: ...
    def getOperation(self) -> str: ...
    def getProxy(self) -> Ice.ObjectPrx: ...
    def getSize(self) -> int: ...

class Communicator:
    @classmethod
    def __init__(cls, initData: Ice.InitializationData | None) -> None: ...
    def _getWrapper(self) -> Ice.Communicator: ...
    def _setWrapper(self, wrapper: Ice.Communicator) -> None: ...
    def addAdminFacet(self, servant: Ice.Object | None, facet: str) -> None: ...
    def createAdmin(self, adminAdapter: Ice.ObjectAdapter | None, adminIdentity: Ice.Identity) -> Ice.ObjectPrx: ...
    def createObjectAdapter(self, name: str) -> ObjectAdapter: ...
    def createObjectAdapterWithEndpoints(self, name: str, endpoints: str) -> ObjectAdapter: ...
    def createObjectAdapterWithRouter(self, name: str, router: Ice.RouterPrx) -> ObjectAdapter: ...
    def destroy(self) -> None: ...
    def destroyAsync(self, callable: Callable) -> None: ...
    def findAdminFacet(self, facet: str) -> Ice.Object: ...
    def findAllAdminFacets(self) -> dict: ...
    def flushBatchRequests(self, compress: Ice.CompressBatch) -> None: ...
    def flushBatchRequestsAsync(self, compress: Ice.CompressBatch) -> Awaitable[None]: ...
    def getAdmin(self) -> Ice.ObjectPrx | None: ...
    def getDefaultLocator(self) -> Ice.LocatorPrx | None: ...
    def getDefaultObjectAdapter(self) -> Ice.ObjectAdapter | None: ...
    def getDefaultRouter(self) -> Ice.RouterPrx | None: ...
    def getImplicitContext(self) -> ImplicitContext | None: ...
    def getLogger(self) -> Ice.Logger | Logger: ...
    def getProperties(self) -> Properties: ...
    def identityToString(self, identity: Ice.Identity) -> str: ...
    def isShutdown(self) -> bool: ...
    def propertyToProxy(self, property: str) -> Ice.ObjectPrx: ...
    def proxyToProperty(self, proxy: Ice.ObjectPrx, property: str) -> dict[str, str]: ...
    def proxyToString(self, proxy: Ice.ObjectPrx | None) -> str: ...
    def removeAdminFacet(self, facet: str) -> Ice.Object: ...
    def setDefaultLocator(self, locator: Ice.LocatorPrx | None) -> None: ...
    def setDefaultObjectAdapter(self, adapter: Ice.ObjectAdapter | None) -> None: ...
    def setDefaultRouter(self, router: Ice.RouterPrx | None) -> None: ...
    def shutdown(self) -> None: ...
    def shutdownCompleted(self) -> Ice.Future: ...
    def stringToProxy(self, str: str) -> Ice.ObjectPrx: ...
    def waitForShutdown(self, timeout: int) -> bool: ...

class Connection:
    ...
    def abort(self) -> None: ...
    def close(self) -> Ice.Future: ...
    def createProxy(self, identity: Ice.Identity) -> Ice.ObjectPrx: ...
    def flushBatchRequests(self, compress: Ice.CompressBatch) -> None: ...
    def flushBatchRequestsAsync(
        self,
        compress: Ice.CompressBatch,
    ) -> Awaitable[None]: ...
    def getAdapter(self) -> Ice.ObjectAdapter | None: ...
    def getEndpoint(self) -> Endpoint: ...
    def getInfo(self) -> Ice.ConnectionInfo: ...
    def setAdapter(self, adapter: Ice.ObjectAdapter | None): ...
    def setBufferSize(self, rcvSize: int, sndSize: int): ...
    def setCloseCallback(self, callback: Callable[[Connection], None]): ...
    # def throwException(self) -> None: ...
    def toString(self) -> str: ...
    def type(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class ConnectionInfo:
    underlying: ConnectionInfo | None
    adapterName: str
    incoming: bool

class DispatchCallback:
    def response(self, *args: tuple) -> None: ...
    def exception(self, exception: BaseException) -> None: ...

class Endpoint:
    def getInfo(self) -> EndpointInfo: ...
    def toString(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class EndpointInfo:
    underlying: EndpointInfo | None
    compress: bool
    def datagram(self) -> bool: ...
    def secure(self) -> bool: ...
    def type(self) -> int: ...

class ExceptionInfo: ...
class ExecutorCall: ...

class IPConnectionInfo(ConnectionInfo):
    localAddress: str
    localPort: int
    remoteAddress: str
    remotePort: int

class IPEndpointInfo(EndpointInfo):
    host: str
    port: int
    sourceAddress: str

class ImplicitContext:
    def containsKey(self, key: str) -> bool: ...
    def get(self, key: str) -> str: ...
    def getContext(self) -> dict[str, str]: ...
    def put(self, key: str, value: str) -> str | None: ...
    def remove(self, key: str) -> str | None: ...
    def setContext(self, newContext: dict[str, str]) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Logger:
    def cloneWithPrefix(self, prefix: str) -> Logger: ...
    def error(self, message: str) -> None: ...
    def getPrefix(self) -> str: ...
    def print(self, message: str) -> None: ...
    def trace(self, category: str, message: str) -> None: ...
    def warning(self, message: str) -> None: ...

class NativePropertiesAdmin:
    def addUpdateCallback(self, callback: Callable[[dict[str, str]], None]) -> None: ...
    def removeUpdateCallback(self, callback: Callable[[dict[str, str]], None]) -> None: ...

class ObjectAdapter:
    def activate(self) -> None: ...
    def add(self, servant: Ice.Object, id: Ice.Identity) -> Ice.ObjectPrx: ...
    def addDefaultServant(self, servant: Ice.Object, category: str) -> None: ...
    def addFacet(self, servant: Ice.Object, id: Ice.Identity, facet: str) -> Ice.ObjectPrx: ...
    def addFacetWithUUID(self, servant: Ice.Object, facet: str) -> Ice.ObjectPrx: ...
    def addServantLocator(self, locator: Ice.ServantLocator, category: str) -> None: ...
    def addWithUUID(self, servant: Ice.Object) -> Ice.ObjectPrx: ...
    def createDirectProxy(self, identity: Ice.Identity) -> Ice.ObjectPrx: ...
    def createIndirectProxy(self, identity: Ice.Identity) -> Ice.ObjectPrx: ...
    def createProxy(self, identity: Ice.Identity) -> Ice.ObjectPrx: ...
    def deactivate(self) -> None: ...
    def destroy(self) -> None: ...
    def find(self, identity: Ice.Identity) -> Ice.Object: ...
    def findAllFacets(self, id: Ice.Identity) -> dict[str, Ice.Object]: ...
    def findByProxy(self, proxy: Ice.ObjectPrx) -> Ice.Object | None: ...
    def findDefaultServant(self, category: str) -> Ice.Object | None: ...
    def findFacet(self, id: Ice.Identity, facet: str) -> Ice.Object | None: ...
    def findServantLocator(self, category: str) -> Ice.ServantLocator | None: ...
    def getCommunicator(self) -> Communicator: ...
    def getEndpoints(self) -> tuple[Endpoint, ...]: ...
    def getLocator(self) -> Ice.LocatorPrx: ...
    def getName(self) -> str: ...
    def getPublishedEndpoints(self) -> tuple[Endpoint, ...]: ...
    def hold(self) -> None: ...
    def isDeactivated(self) -> bool: ...
    def remove(self, id: Ice.Identity) -> Ice.Object: ...
    def removeAllFacets(self, id: Ice.Identity) -> dict[str, Ice.Object]: ...
    def removeDefaultServant(self, category: str) -> Ice.Object: ...
    def removeFacet(self, id: Ice.Identity, facet: str) -> Ice.Object: ...
    def removeServantLocator(self, category: str) -> Ice.ServantLocator: ...
    def setLocator(self, locator: Ice.LocatorPrx) -> None: ...
    def setPublishedEndpoints(self, newEndpoints: tuple[Endpoint, ...] | list[Endpoint]) -> None: ...
    def waitForDeactivate(self, timeout: int) -> bool: ...
    def waitForHold(self, timeout: int) -> None: ...

class ObjectPrx:
    def __init__(self, communicator: Ice.Communicator, endpoint: str) -> None: ...
    def ice_adapterId(self, newAdapterId: str) -> Self: ...
    def ice_batchDatagram(self) -> Self: ...
    def ice_batchOneway(self) -> Self: ...
    def ice_collocationOptimized(self, collocated: bool) -> Self: ...
    def ice_compress(self, compress: bool) -> Self: ...
    def ice_connectionCached(self, newCache: bool) -> Self: ...
    def ice_connectionId(self, connectionId: str) -> Self: ...
    def ice_context(self, new_context: dict[str, str]) -> Self: ...
    def ice_datagram(self) -> Self: ...
    def ice_encodingVersion(self, version: Ice.EncodingVersion) -> Self: ...
    def ice_endpointSelection(self, newType: Ice.EndpointSelectionType) -> Self: ...
    def ice_endpoints(self, newEndpoints: tuple[Endpoint, ...] | list[Endpoint]) -> Self: ...
    def ice_facet(self, new_facet: str) -> Self: ...
    def ice_fixed(self, connection: Connection) -> Self: ...
    def ice_flushBatchRequests(self) -> None: ...
    def ice_flushBatchRequestsAsync(self) -> Awaitable[None]: ...
    def ice_getAdapterId(self) -> str: ...
    def ice_getCachedConnection(self) -> Connection | None: ...
    def ice_getCommunicator(self) -> Ice.Communicator: ...
    def ice_getCompress(self) -> bool | None: ...
    def ice_getConnection(self) -> Connection | None: ...
    def ice_getConnectionAsync(self) -> Awaitable[Connection | None]:
        """
        Returns the Connection for this proxy. If the proxy does not yet have an established connection,
        it first attempts to create a connection.

        Returns
        -------
        Awaitable[Connection | None]
            An Awaitable that resolves to the Connection for this proxy.
        """
        ...

    def ice_getConnectionId(self) -> str: ...
    def ice_getContext(self) -> dict[str, str] | None: ...
    def ice_getEncodingVersion(self) -> Ice.EncodingVersion: ...
    def ice_getEndpointSelection(self) -> Ice.EndpointSelectionType: ...
    def ice_getEndpoints(self) -> tuple[Endpoint, ...]: ...
    def ice_getFacet(self) -> str: ...
    def ice_getIdentity(self) -> Ice.Identity: ...
    def ice_getInvocationTimeout(self) -> int: ...
    def ice_getLocator(self) -> Ice.LocatorPrx | None: ...
    def ice_getLocatorCacheTimeout(self) -> int: ...
    def ice_getRouter(self) -> Ice.RouterPrx | None: ...
    def ice_identity(self, newIdentity: Ice.Identity) -> Self: ...
    def ice_invocationTimeout(self, timeout: int) -> Self: ...
    def ice_invoke(
        self, operation: str, mode: Ice.OperationMode, inParams: bytes, ctx: dict[str, str] | None
    ) -> tuple[bool, bytes]: ...
    def ice_invokeAsync(
        self, operation: str, mode: Ice.OperationMode, inParams: bytes, ctx: dict[str, str] | None
    ) -> Awaitable[tuple[bool, bytes]]: ...
    def ice_isBatchDatagram(self) -> bool: ...
    def ice_isBatchOneway(self) -> bool: ...
    def ice_isCollocationOptimized(self) -> bool: ...
    def ice_isConnectionCached(self) -> bool: ...
    def ice_isDatagram(self) -> bool: ...
    def ice_isFixed(self) -> bool: ...
    def ice_isOneway(self) -> bool: ...
    def ice_isTwoway(self) -> bool: ...
    def ice_locator(self, locator: Ice.LocatorPrx | None) -> Self: ...
    def ice_locatorCacheTimeout(self, timeout: int) -> Self: ...
    def ice_oneway(self) -> Self: ...
    def ice_router(self, router: Ice.RouterPrx | None) -> Self: ...
    def ice_toString(self) -> str: ...
    def ice_twoway(self) -> Self: ...
    @staticmethod
    def newProxy(type: Type[T], proxy: Ice.ObjectPrx) -> T: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class OpaqueEndpointInfo(EndpointInfo):
    rawBytes: bytes
    rawEncoding: Ice.EncodingVersion

class Operation:
    def __init__(
        self,
        name: str,
        ice_name: str,
        mode: Any,
        format: Any,
        input_params: tuple,
        output_params: tuple,
        return_value: tuple,
        return_type: Any,
        exceptions: tuple,
    ) -> None: ...
    def deprecate(self, reason: str): ...
    def invoke(self, proxy: ObjectPrx, args: tuple) -> Any: ...
    def invokeAsync(self, proxy: ObjectPrx, args: tuple) -> Awaitable[Any]: ...

class Properties:
    def clone(self) -> Properties: ...
    def getCommandLineOptions(self) -> list[str]: ...
    def getIceProperty(self, key: str) -> str: ...
    def getIcePropertyAsInt(self, key: str) -> int: ...
    def getIcePropertyAsList(self, key: str) -> list[str]: ...
    def getPropertiesForPrefix(self, prefix: str) -> dict[str, str]: ...
    def getProperty(self, key: str) -> str: ...
    def getPropertyAsInt(self, key: str) -> int: ...
    def getPropertyAsIntWithDefault(self, key: str, default: int) -> int: ...
    def getPropertyAsList(self, key: str) -> list[str]: ...
    def getPropertyAsListWithDefault(self, key: str, default: list[str]) -> list[str]: ...
    def getPropertyWithDefault(self, key: str, default: str) -> str: ...
    def load(self, file: str) -> None: ...
    def parseCommandLineOptions(self, prefix: str, options: list[str]) -> list[str]: ...
    def parseIceCommandLineOptions(self, options: list[str]) -> list[str]: ...
    def setProperty(self, key: str, value: str) -> None: ...

class SSLConnectionInfo(ConnectionInfo):
    ...
    peerCertificate: str

class SSLEndpointInfo(EndpointInfo): ...

class TCPConnectionInfo(IPConnectionInfo):
    rcvSize: int
    sndSize: int

class TCPEndpointInfo(IPEndpointInfo): ...

class UDPConnectionInfo(IPConnectionInfo):
    mcastAddress: str
    mcastPort: int
    rcvSize: int
    sndSize: int

class UDPEndpointInfo(IPEndpointInfo):
    mcastInterface: str
    mcastTtl: int

class WSConnectionInfo(ConnectionInfo):
    headers: dict[str, str]

class WSEndpointInfo(EndpointInfo):
    resource: str

def compileSlice(args: list[str]) -> int: ...
def createProperties(args: list[str] | None, defaults: Ice.Properties | None): ...
def currentEncoding() -> Ice.EncodingVersion: ...
def currentProtocol() -> Ice.ProtocolVersion: ...
def currentProtocolEncoding() -> Ice.EncodingVersion: ...
def stringVersion() -> str: ...
def intVersion() -> int: ...
def encodingVersionToString(encoding: Ice.EncodingVersion) -> str: ...
def protocolVersionToString(protocol: Ice.ProtocolVersion) -> str: ...
def stringToEncodingVersion(str: str) -> Ice.EncodingVersion: ...
def stringToProtocolVersion(str: str) -> Ice.ProtocolVersion: ...
def identityToString(identity: Ice.Identity, toStringMode: Ice.ToStringMode | None = None) -> str: ...
def getProcessLogger() -> Ice.Logger: ...
def setProcessLogger(logger: Ice.Logger) -> None: ...
def loadSlice(args: list[str]) -> None: ...
def stringToIdentity(str: str) -> Ice.Identity: ...

#
# Internal API for IcePy
#
def declareProxy(sliceId: str): ...
def defineProxy(
    sliceId: str,
    proxyType: Type[ObjectPrx],
): ...
def declareValue(sliceId: str): ...
def defineValue(
    sliceId: str,
    valueType: Type[Ice.Value],
    compactId: int,
    meta: tuple,
    isInterface: bool,
    baseType: Type[Ice.Value] | None,
    members: tuple,
): ...
def defineDictionary(sliceId: str, meta: tuple, keyType: TypeInfo, valueType: TypeInfo): ...
def defineEnum(sliceId: str, type: Type, meta: tuple, enumerators: dict): ...
def defineException(
    sliceId: str, type: Type[BaseException], meta: tuple, base: Type[BaseException] | None, members: tuple
): ...
def defineSequence(sliceId: str, meta: tuple, elementType: TypeInfo): ...
def defineStruct(sliceId: str, type: Type, meta: tuple, members: tuple): ...

class TypeInfo: ...

_t_string: TypeInfo
_t_short: TypeInfo
_t_bool: TypeInfo
_t_int: TypeInfo
_t_long: TypeInfo
_t_byte: TypeInfo
_t_double: TypeInfo
_t_float: TypeInfo
_t_UnknownSlicedValue: TypeInfo
_t_ObjectPrx: TypeInfo
_t_Value: TypeInfo
