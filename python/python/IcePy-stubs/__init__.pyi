# Copyright (c) ZeroC, Inc.

# IcePy contains (unfortunately) a mix of public and internal APIs.
# The public APIs, things that get re-exported through Ice, must be documented; internal APIs do not.
#
# These doc comments must be synchronized with the documentation in the corresponding IcePy C++ files.
# 1. Sphinx uses the doc comments from the IcePy native module directly.
# 2. IcePy stubs (this file) are used by pyright and IDEs for type checking and code completion.
#
# It would be nice if this file could be generated automatically from the C++ files using `stubgen`,
# but for now we maintain it manually since the generated stubs are incomplete for use with pyright.

from collections.abc import Awaitable, Callable
from typing import Any, Self, Type, TypeVar

import Ice

T = TypeVar("T", bound=Ice.ObjectPrx)

class AsyncInvocationContext:
    def cancel(self) -> None: ...

class BatchRequest:
    """
    Represents a batch request.
    A batch request is created by invoking an operation on a batch-oneway or batch-datagram proxy.
    """

    def enqueue(self) -> None:
        """
        Queues this request.
        """
        ...

    def getOperation(self) -> str:
        """
        Gets the name of the operation.

        Returns
        -------
        str
            The operation name.
        """
        ...

    def getProxy(self) -> Ice.ObjectPrx:
        """
        Gets the proxy used to create this batch request.

        Returns
        -------
        Ice.ObjectPrx
            The proxy.
        """
        ...

    def getSize(self) -> int:
        """
        Gets the size of the request.

        Returns
        -------
        int
            The number of bytes consumed by the request.
        """
        ...

class Communicator:
    @classmethod
    def __init__(cls, initData: Ice.InitializationData | None) -> None: ...
    def _getWrapper(self) -> Ice.Communicator: ...
    def _setWrapper(self, wrapper: Ice.Communicator) -> None: ...
    def addAdminFacet(self, servant: Ice.Object | None, facet: str) -> None: ...
    def createAdmin(self, adminAdapter: Ice.ObjectAdapter | None, adminIdentity: Ice.Identity) -> Ice.ObjectPrx: ...
    def createObjectAdapter(self, name: str) -> ObjectAdapter: ...
    def createObjectAdapterWithEndpoints(self, name: str, endpoints: str) -> ObjectAdapter: ...
    def createObjectAdapterWithRouter(self, name: str, router: Ice.RouterPrx) -> ObjectAdapter: ...
    def destroy(self) -> None: ...
    def destroyAsync(self, callable: Callable) -> None: ...
    def findAdminFacet(self, facet: str) -> Ice.Object: ...
    def findAllAdminFacets(self) -> dict: ...
    def flushBatchRequests(self, compress: Ice.CompressBatch) -> None: ...
    def flushBatchRequestsAsync(self, compress: Ice.CompressBatch) -> Awaitable[None]: ...
    def getAdmin(self) -> Ice.ObjectPrx | None: ...
    def getDefaultLocator(self) -> Ice.LocatorPrx | None: ...
    def getDefaultObjectAdapter(self) -> Ice.ObjectAdapter | None: ...
    def getDefaultRouter(self) -> Ice.RouterPrx | None: ...
    def getImplicitContext(self) -> ImplicitContext | None: ...
    def getLogger(self) -> Ice.Logger | Logger: ...
    def getProperties(self) -> Properties: ...
    def identityToString(self, identity: Ice.Identity) -> str: ...
    def isShutdown(self) -> bool: ...
    def propertyToProxy(self, property: str) -> Ice.ObjectPrx: ...
    def proxyToProperty(self, proxy: Ice.ObjectPrx, property: str) -> dict[str, str]: ...
    def proxyToString(self, proxy: Ice.ObjectPrx | None) -> str: ...
    def removeAdminFacet(self, facet: str) -> Ice.Object: ...
    def setDefaultLocator(self, locator: Ice.LocatorPrx | None) -> None: ...
    def setDefaultObjectAdapter(self, adapter: Ice.ObjectAdapter | None) -> None: ...
    def setDefaultRouter(self, router: Ice.RouterPrx | None) -> None: ...
    def shutdown(self) -> None: ...
    def shutdownCompleted(self) -> Awaitable[None]: ...
    def stringToProxy(self, str: str) -> Ice.ObjectPrx: ...
    def waitForShutdown(self, timeout: int) -> bool: ...

class Connection:
    """Represents a connection that uses the Ice protocol."""

    def abort(self) -> None:
        """Aborts this connection."""
        ...

    def close(self) -> Awaitable[None]:
        """
        Starts a graceful closure of this connection once all outstanding invocations have completed.

        Returns
        -------
        Awaitable[None]
            A future that becomes available when the connection is closed.
        """
        ...

    def createProxy(self, identity: Ice.Identity) -> Ice.ObjectPrx:
        """
        Creates a special proxy (a 'fixed proxy') that always uses this connection.

        Parameters
        ----------
        identity : Ice.Identity
            The identity of the target object.

        Returns
        -------
        Ice.ObjectPrx
            A fixed proxy with the provided identity.
        """
        ...

    def disableInactivityCheck(self) -> None:
        """
        Disables the inactivity check on this connection.

        By default, Ice will close connections that remain inactive for a certain period.
        This function disables that behavior for this connection.
        """
        ...

    def setAdapter(self, adapter: Ice.ObjectAdapter | None) -> None:
        """
        Associates an object adapter with this connection.

        When a connection receives a request, it dispatches this request using its associated object adapter.
        If the associated object adapter is ``None``, the connection rejects any incoming request with an
        :class:`ObjectNotExistException`.

        The default object adapter of an incoming connection is the object adapter that created this connection;
        the default object adapter of an outgoing connection is the communicator's default object adapter.

        Parameters
        ----------
        adapter : Ice.ObjectAdapter | None
            The object adapter to associate with this connection.
        """
        ...

    def getAdapter(self) -> Ice.ObjectAdapter | None:
        """
        Gets the object adapter associated with this connection.

        Returns
        -------
        Ice.ObjectAdapter | None
            The object adapter associated with this connection.
        """
        ...

    def flushBatchRequests(self, compress: Ice.CompressBatch) -> None:
        """
        Flushes any pending batch requests for this connection.

        This corresponds to all batch requests invoked on fixed proxies associated with the connection.

        Parameters
        ----------
        compress : Ice.CompressBatch
            Specifies whether or not the queued batch requests should be compressed before being sent over the wire.
        """
        ...

    def flushBatchRequestsAsync(
        self,
        compress: Ice.CompressBatch,
    ) -> Awaitable[None]:
        """
        Flushes any pending batch requests for this connection asynchronously.

        This corresponds to all batch requests invoked on fixed proxies associated with the connection.

        Parameters
        ----------
        compress : Ice.CompressBatch
            Specifies whether or not the queued batch requests should be compressed before being sent over the wire.

        Returns
        -------
        Awaitable[None]
            A future that becomes available when the flush completes.
        """
        ...

    def setCloseCallback(self, callback: Callable[[Connection], None]) -> None:
        """
        Sets a close callback on the connection. The callback is called by the connection when it's closed.
        The callback is called from the Ice thread pool associated with the connection.

        Parameters
        ----------
        callback : Callable[[Connection], None]
            The close callback callable.
        """
        ...

    def type(self) -> str:
        """
        Returns the connection type. This corresponds to the endpoint type, such as 'tcp', 'udp', etc.

        Returns
        -------
        str
            The type of the connection.
        """
        ...

    def toString(self) -> str:
        """
        Returns a description of the connection as human readable text, suitable for logging or error messages.

        Notes
        -----
        This function remains usable after the connection is closed or aborted.

        Returns
        -------
        str
            The description of the connection as human readable text.
        """
        ...

    def getInfo(self) -> Ice.ConnectionInfo:
        """
        Returns the connection information.

        Returns
        -------
        Ice.ConnectionInfo
            The connection information.
        """
        ...

    def getEndpoint(self) -> Endpoint:
        """
        Gets the endpoint from which the connection was created.

        Returns
        -------
        Ice.Endpoint
            The endpoint from which the connection was created.
        """
        ...

    def setBufferSize(self, rcvSize: int, sndSize: int) -> None:
        """
        Sets the size of the receive and send buffers.

        Parameters
        ----------
        rcvSize : int
            The size of the receive buffer.
        sndSize : int
            The size of the send buffer.
        """
        ...

    def throwException(self) -> None:
        """
        Raises an exception that provides the reason for the closure of this connection. For example,
        this function raises :class:`CloseConnectionException` when the connection was closed gracefully by the peer;
        it raises :class:`ConnectionAbortedException` when the connection is aborted with :func:`abort`.
        This function does nothing if the connection is not yet closed.
        """
        ...

    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class ConnectionInfo:
    """
    Base class for all connection info classes.
    """

    underlying: ConnectionInfo | None
    """
    ConnectionInfo | None: The information of the underlying transport or ``None`` if there's no underlying transport.
    """

    incoming: bool
    """bool: ``True`` if this is an incoming connection, ``False`` otherwise."""

    adapterName: str
    """str: The name of the adapter associated with the connection."""

class DispatchCallback:
    def response(self, *args: tuple) -> None: ...
    def exception(self, exception: BaseException) -> None: ...

class Endpoint:
    """
    An endpoint specifies the address of the server-end of an Ice connection.
    An object adapter listens on one or more endpoints and a client establishes a connection to an endpoint.
    """

    def toString(self) -> str:
        """
        Returns a string representation of this endpoint.

        Returns
        -------
        str
            The string representation of this endpoint.
        """
        ...

    def getInfo(self) -> EndpointInfo:
        """
        Returns this endpoint's information.

        Returns
        -------
        Ice.EndpointInfo
            This endpoint's information class.
        """
        ...

    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class EndpointInfo:
    """
    Base class for the endpoint info classes.
    """

    underlying: EndpointInfo | None
    """The information of the underlying endpoint or ``None`` if there's no underlying endpoint."""

    compress: bool
    """Specifies whether or not compression should be used if available when using this endpoint."""

    def type(self) -> int:
        """
        Returns the type of the endpoint.

        Returns
        -------
        int
            The endpoint type.
        """
        ...

    def datagram(self) -> bool:
        """
        Returns whether this endpoint is a datagram endpoint (namely, UDP).

        Returns
        -------
        bool
            ``True`` for a UDP endpoint, ``False`` otherwise.
        """
        ...

    def secure(self) -> bool:
        """
        Returns whether this endpoint uses SSL.

        Returns
        -------
        bool
            ``True`` for SSL and SSL-based transports, ``False`` otherwise.
        """
        ...

class ExceptionInfo: ...
class ExecutorCall: ...

class IPConnectionInfo(ConnectionInfo):
    """Provides access to the connection details of an IP connection."""

    localAddress: str
    """str: The local address."""

    localPort: int
    """int: The local port."""

    remoteAddress: str
    """str: The remote address."""

    remotePort: int
    """int: The remote port."""

class IPEndpointInfo(EndpointInfo):
    """Provides access to the address details of an IP endpoint."""

    host: str
    """str: The host or address configured with the endpoint."""

    port: int
    """int: The port number."""

    sourceAddress: str
    """str: The source IP address."""

class ImplicitContext:
    def containsKey(self, key: str) -> bool: ...
    def get(self, key: str) -> str: ...
    def getContext(self) -> dict[str, str]: ...
    def put(self, key: str, value: str) -> str | None: ...
    def remove(self, key: str) -> str | None: ...
    def setContext(self, newContext: dict[str, str]) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Logger:
    def cloneWithPrefix(self, prefix: str) -> Logger: ...
    def error(self, message: str) -> None: ...
    def getPrefix(self) -> str: ...
    def print(self, message: str) -> None: ...
    def trace(self, category: str, message: str) -> None: ...
    def warning(self, message: str) -> None: ...

class NativePropertiesAdmin:
    """
    The default implementation of the 'Properties' admin facet.
    """

    def addUpdateCallback(self, callback: Callable[[dict[str, str]], None]) -> None:
        """
        Registers an update callback that will be invoked when a property update occurs.

        Parameters
        ----------
        callback : Callable[[dict[str, str]], None]
            The callback.
        """
        ...

    def removeUpdateCallback(self, callback: Callable[[dict[str, str]], None]) -> None:
        """
        Removes a previously registered update callback.

        Parameters
        ----------
        callback : Callable[[dict[str, str]], None]
            The callback to remove.
        """
        ...

class ObjectAdapter:
    def activate(self) -> None: ...
    def add(self, servant: Ice.Object, id: Ice.Identity) -> Ice.ObjectPrx: ...
    def addDefaultServant(self, servant: Ice.Object, category: str) -> None: ...
    def addFacet(self, servant: Ice.Object, id: Ice.Identity, facet: str) -> Ice.ObjectPrx: ...
    def addFacetWithUUID(self, servant: Ice.Object, facet: str) -> Ice.ObjectPrx: ...
    def addServantLocator(self, locator: Ice.ServantLocator, category: str) -> None: ...
    def addWithUUID(self, servant: Ice.Object) -> Ice.ObjectPrx: ...
    def createDirectProxy(self, identity: Ice.Identity) -> Ice.ObjectPrx: ...
    def createIndirectProxy(self, identity: Ice.Identity) -> Ice.ObjectPrx: ...
    def createProxy(self, identity: Ice.Identity) -> Ice.ObjectPrx: ...
    def deactivate(self) -> None: ...
    def destroy(self) -> None: ...
    def find(self, identity: Ice.Identity) -> Ice.Object | None: ...
    def findAllFacets(self, id: Ice.Identity) -> dict[str, Ice.Object]: ...
    def findByProxy(self, proxy: Ice.ObjectPrx) -> Ice.Object | None: ...
    def findDefaultServant(self, category: str) -> Ice.Object | None: ...
    def findFacet(self, id: Ice.Identity, facet: str) -> Ice.Object | None: ...
    def findServantLocator(self, category: str) -> Ice.ServantLocator | None: ...
    def getCommunicator(self) -> Communicator: ...
    def getEndpoints(self) -> tuple[Endpoint, ...]: ...
    def getLocator(self) -> Ice.LocatorPrx: ...
    def getName(self) -> str: ...
    def getPublishedEndpoints(self) -> tuple[Endpoint, ...]: ...
    def hold(self) -> None: ...
    def isDeactivated(self) -> bool: ...
    def remove(self, id: Ice.Identity) -> Ice.Object: ...
    def removeAllFacets(self, id: Ice.Identity) -> dict[str, Ice.Object]: ...
    def removeDefaultServant(self, category: str) -> Ice.Object: ...
    def removeFacet(self, id: Ice.Identity, facet: str) -> Ice.Object: ...
    def removeServantLocator(self, category: str) -> Ice.ServantLocator: ...
    def setLocator(self, locator: Ice.LocatorPrx) -> None: ...
    def setPublishedEndpoints(self, newEndpoints: tuple[Endpoint, ...] | list[Endpoint]) -> None: ...
    def waitForDeactivate(self, timeout: int) -> bool: ...
    def waitForHold(self, timeout: int) -> None: ...

class ObjectPrx:
    def __init__(self, communicator: Ice.Communicator, endpoint: str) -> None: ...
    def ice_adapterId(self, newAdapterId: str) -> Self: ...
    def ice_batchDatagram(self) -> Self: ...
    def ice_batchOneway(self) -> Self: ...
    def ice_collocationOptimized(self, collocated: bool) -> Self: ...
    def ice_compress(self, compress: bool) -> Self: ...
    def ice_connectionCached(self, newCache: bool) -> Self: ...
    def ice_connectionId(self, connectionId: str) -> Self: ...
    def ice_context(self, new_context: dict[str, str]) -> Self: ...
    def ice_datagram(self) -> Self: ...
    def ice_encodingVersion(self, version: Ice.EncodingVersion) -> Self: ...
    def ice_endpointSelection(self, newType: Ice.EndpointSelectionType) -> Self: ...
    def ice_endpoints(self, newEndpoints: tuple[Endpoint, ...] | list[Endpoint]) -> Self: ...
    def ice_facet(self, new_facet: str) -> Self: ...
    def ice_fixed(self, connection: Ice.Connection) -> Self: ...
    def ice_flushBatchRequests(self) -> None: ...
    def ice_flushBatchRequestsAsync(self) -> Awaitable[None]: ...
    def ice_getAdapterId(self) -> str: ...
    def ice_getCachedConnection(self) -> Ice.Connection | None: ...
    def ice_getCommunicator(self) -> Ice.Communicator: ...
    def ice_getCompress(self) -> bool | None: ...
    def ice_getConnection(self) -> Ice.Connection | None: ...
    def ice_getConnectionAsync(self) -> Awaitable[Ice.Connection | None]: ...
    def ice_getConnectionId(self) -> str: ...
    def ice_getContext(self) -> dict[str, str] | None: ...
    def ice_getEncodingVersion(self) -> Ice.EncodingVersion: ...
    def ice_getEndpointSelection(self) -> Ice.EndpointSelectionType: ...
    def ice_getEndpoints(self) -> tuple[Endpoint, ...]: ...
    def ice_getFacet(self) -> str: ...
    def ice_getIdentity(self) -> Ice.Identity: ...
    def ice_getInvocationTimeout(self) -> int: ...
    def ice_getLocator(self) -> Ice.LocatorPrx | None: ...
    def ice_getLocatorCacheTimeout(self) -> int: ...
    def ice_getRouter(self) -> Ice.RouterPrx | None: ...
    def ice_identity(self, newIdentity: Ice.Identity) -> Self: ...
    def ice_invocationTimeout(self, timeout: int) -> Self: ...
    def ice_invoke(
        self, operation: str, mode: Ice.OperationMode, inParams: bytes, ctx: dict[str, str] | None
    ) -> tuple[bool, bytes]: ...
    def ice_invokeAsync(
        self, operation: str, mode: Ice.OperationMode, inParams: bytes, ctx: dict[str, str] | None
    ) -> Awaitable[tuple[bool, bytes]]: ...
    def ice_isBatchDatagram(self) -> bool: ...
    def ice_isBatchOneway(self) -> bool: ...
    def ice_isCollocationOptimized(self) -> bool: ...
    def ice_isConnectionCached(self) -> bool: ...
    def ice_isDatagram(self) -> bool: ...
    def ice_isFixed(self) -> bool: ...
    def ice_isOneway(self) -> bool: ...
    def ice_isTwoway(self) -> bool: ...
    def ice_locator(self, locator: Ice.LocatorPrx | None) -> Self: ...
    def ice_locatorCacheTimeout(self, timeout: int) -> Self: ...
    def ice_oneway(self) -> Self: ...
    def ice_router(self, router: Ice.RouterPrx | None) -> Self: ...
    def ice_toString(self) -> str: ...
    def ice_twoway(self) -> Self: ...
    @staticmethod
    def newProxy(type: Type[T], proxy: Ice.ObjectPrx) -> T: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class OpaqueEndpointInfo(EndpointInfo):
    """Provides access to the details of an opaque endpoint."""

    rawBytes: bytes
    """bytes: The raw encoding of the opaque endpoint."""

    rawEncoding: Ice.EncodingVersion
    """Ice.EncodingVersion: The encoding version of the opaque endpoint (to decode or encode the ``rawBytes``)."""

class Operation:
    def __init__(
        self,
        name: str,
        ice_name: str,
        mode: Any,
        format: Any,
        input_params: tuple,
        output_params: tuple,
        return_value: tuple,
        return_type: Any,
        exceptions: tuple,
    ) -> None: ...
    def invoke(self, proxy: ObjectPrx, args: tuple) -> Any: ...
    def invokeAsync(self, proxy: ObjectPrx, args: tuple) -> Awaitable[Any]: ...
    def deprecate(self, reason: str): ...

class Properties:
    def getProperty(self, key: str) -> str: ...
    def getIceProperty(self, key: str) -> str: ...
    def getPropertyWithDefault(self, key: str, value: str) -> str: ...
    def getPropertyAsInt(self, key: str) -> int: ...
    def getIcePropertyAsInt(self, key: str) -> int: ...
    def getPropertyAsIntWithDefault(self, key: str, value: int) -> int: ...
    def getPropertyAsList(self, key: str) -> list[str]: ...
    def getIcePropertyAsList(self, key: str) -> list[str]: ...
    def getPropertyAsListWithDefault(self, key: str, value: list[str]) -> list[str]: ...
    def getPropertiesForPrefix(self, prefix: str) -> dict[str, str]: ...
    def setProperty(self, key: str, value: str) -> None: ...
    def getCommandLineOptions(self) -> list[str]: ...
    def parseCommandLineOptions(self, prefix: str, options: list[str]) -> list[str]: ...
    def parseIceCommandLineOptions(self, options: list[str]) -> list[str]: ...
    def load(self, file: str) -> None: ...
    def clone(self) -> Properties: ...

class SSLConnectionInfo(ConnectionInfo):
    """Provides access to the connection details of an SSL connection."""

    peerCertificate: str
    """str: The certificate chain."""

class SSLEndpointInfo(EndpointInfo):
    """Provides access to an SSL endpoint information."""

    ...

class TCPConnectionInfo(IPConnectionInfo):
    """Provides access to the connection details of a TCP connection."""

    rcvSize: int
    """int: The size of the receive buffer."""

    sndSize: int
    """int: The size of the send buffer."""

class TCPEndpointInfo(IPEndpointInfo):
    """Provides access to a TCP endpoint information."""

    ...

class UDPConnectionInfo(IPConnectionInfo):
    """Provides access to the connection details of a UDP connection."""

    mcastAddress: str
    """str: The multicast address."""

    mcastPort: int
    """int: The multicast port."""

    rcvSize: int
    """int: The size of the receive buffer."""

    sndSize: int
    """int: The size of the send buffer."""

class UDPEndpointInfo(IPEndpointInfo):
    """Provides access to a UDP endpoint information."""

    mcastInterface: str
    """str: The multicast interface."""

    mcastTtl: int
    """int: The multicast time-to-live (or hops)."""

class WSConnectionInfo(ConnectionInfo):
    """Provides access to the connection details of a WebSocket connection."""

    headers: dict[str, str]
    """dict[str, str]: The headers from the HTTP upgrade request."""

class WSEndpointInfo(EndpointInfo):
    """Provides access to a WebSocket endpoint information."""

    resource: str
    """str: The URI configured with the endpoint."""

def stringVersion() -> str: ...
def intVersion() -> int: ...
def createProperties(args: list[str] | None = None, defaults: Ice.Properties | None = None) -> Properties: ...
def stringToIdentity(str: str) -> Ice.Identity: ...
def identityToString(identity: Ice.Identity, toStringMode: Ice.ToStringMode | None = None) -> str: ...
def getProcessLogger() -> Ice.Logger: ...
def setProcessLogger(logger: Ice.Logger) -> None: ...

#
# Functions to load/compile Slice definitions with 'slice2py'.
#
def loadSlice(args: list[str]) -> None: ...
def compileSlice(args: list[str]) -> int: ...

#
# Internal API for IcePy
#
def declareProxy(sliceId: str): ...
def defineProxy(
    sliceId: str,
    proxyType: Type[ObjectPrx],
): ...
def declareValue(sliceId: str): ...
def defineValue(
    sliceId: str,
    valueType: Type[Ice.Value],
    compactId: int,
    meta: tuple,
    isInterface: bool,
    baseType: Type[Ice.Value] | None,
    members: tuple,
): ...
def defineDictionary(sliceId: str, meta: tuple, keyType: TypeInfo, valueType: TypeInfo): ...
def defineEnum(sliceId: str, type: Type, meta: tuple, enumerators: dict): ...
def defineException(
    sliceId: str, type: Type[BaseException], meta: tuple, base: Type[BaseException] | None, members: tuple
): ...
def defineSequence(sliceId: str, meta: tuple, elementType: TypeInfo): ...
def defineStruct(sliceId: str, type: Type, meta: tuple, members: tuple): ...

class TypeInfo: ...

_t_string: TypeInfo
_t_short: TypeInfo
_t_bool: TypeInfo
_t_int: TypeInfo
_t_long: TypeInfo
_t_byte: TypeInfo
_t_double: TypeInfo
_t_float: TypeInfo
_t_UnknownSlicedValue: TypeInfo
_t_ObjectPrx: TypeInfo
_t_Value: TypeInfo
